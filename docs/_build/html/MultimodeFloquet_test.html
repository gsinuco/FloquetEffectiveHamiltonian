
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>How to build the library and compile the examples &#8212; ShakenOptic 0+untagged.14.gaa02efe.dirty documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Credits" href="authors.html" />
    <link rel="prev" title="Contributing" href="contributing.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="authors.html" title="Credits"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="contributing.html" title="Contributing"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">ShakenOptic 0+untagged.14.gaa02efe.dirty documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="how-to-build-the-library-and-compile-the-examples">
<h1>How to build the library and compile the examples<a class="headerlink" href="#how-to-build-the-library-and-compile-the-examples" title="Permalink to this headline">¶</a></h1>
<p>The openMMF source code includes a Makefile file for compiling and
building the library. The user must ensure that make.inc sets correctly
the system’s path to the LAPACK and (optionally) the MKL-intel libraries
and linking/compiling options.</p>
<p>When the paths are set correctly, compiling the library requires
invoking a single make command, which will build the library. To
indicate whether the MKL library can be used, the user should indicate
so in make.inc . The make builing options are:</p>
<ul class="simple">
<li>make : Compiles the library and selected Fortran and C++ examples</li>
<li>make lib : compiles the library including support for sparse
matrices. This option requires the LAPACK and MKL-intel libraries.</li>
<li>make lib_lapack : compiles the library without support for sparse
matrices. This option requires LAPACK.</li>
<li>make Examples_lib : compilies examples under the folder
examples/FORTRAN , which uses LAPACK</li>
<li>make Examples_lib_sp : compilies examples under the folder
examples/FORTRAN , which uses the MKL library</li>
<li>make Examples_lib_c : compilies examples under the folder
examples/CPP , which uses LAPACK</li>
<li>make Examples_lib_c_sp : compilies examples under the folder
examples/CPP , which uses the MKL library</li>
<li>make : run the options lib and all_examples .</li>
</ul>
<p>All options of the make command produces static and dynamical libraries
libopenmmf.a and libopenmmf.so in the folder &nbsp;/lib . A number of .mod
files produced with the building process are moved to the folder
&nbsp;/include and they are required for running the application.</p>
<p>The examples that only require the support of the LAPACK library are
compiled with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>gfortran -o out SourceCode.f90 -I$(INCLUDE_OPENMMF) -L$(LIB_OPENMMF) -lopenmmf $(GFFLAGS)
g++      -o out SourceCode.cpp -I$(INCLUDE_OPENMMF) -L$(LIB_OPENMMF) -lopenmmf -lgfortran $(GFFLAGS)
</pre></div>
</div>
<p>while code that requires support from the MKL library is compiled by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>gfortran -o out SourceCode.f90 -I$(INCLUDE_OPENMMF) -L$(LIB_OPENMMF) -lopenmmf
                               -L$(MKLLIBS) -I$(MKLINC) $(MKLFLAGS)
g++      -o out SourceCode.cpp -I$(INCLUDE_OPENMMF) -L$(LIB_OPENMMF) -lopenmmf -lgfortran
                               -L$(MKLLIBS) -I$(MKLINC) $(MKLFLAGS)
</pre></div>
</div>
<p>The variables MKLLIBS , MKLINC , GFFLAGS , and MKLFLAGS are defined in
the file Makefile . The environmental variables INCLUDE_OPENMMF and
LIB_OPENMMF indicate the paths to the include and library directories of
the openMMF library. Compilation of C++ source code follows the same
formula, using the additional flag -lgfortran and the corresponding
compiler g++ . For an explicit example of usage in this case see the
building script under examples/CPP/Makefile .</p>
<p>When running applications, the environmental variable LD_LIBRARY_PATH
must indicate the path to such a library, which can be done with the
shell command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">export</span> <span class="n">LD_LIBRARY_PATH</span><span class="o">=</span><span class="s2">&quot;/opt/intel/compilers_and_libraries/linux/mkl/lib/intel64:./lib&quot;</span>
</pre></div>
</div>
<p>which assumes default folder location of the MKL library and that
libopenmmf is located in ./lib .</p>
</div>
<div class="section" id="what-does-the-library-calculate-and-how">
<h1>What does the library calculate and how?<a class="headerlink" href="#what-does-the-library-calculate-and-how" title="Permalink to this headline">¶</a></h1>
<p>The library can be used to calculate the time-evolution operator,
<span class="math notranslate nohighlight">\(U(t',t), ~ t'&gt;t\)</span>, of systems whose Hamiltonian has the form:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}  H = \sum_{i,j}^D E_{i,j} \left| i\right\rangle \left\langle j \right| + \sum_{i,j}^D \sum_{\ell=1}^N \sum_{n \in Z} V_{i,j}^{\ell,n} e^{i n \omega_\ell t} \left| i\right\rangle \left\langle j \right| + \textrm{h.c.}
  \label{eq:Hamiltonian}\\where :math:`D` is the dimension of the Hilbert space,\end{aligned}\end{align} \]</div>
<p><span class="math notranslate nohighlight">\({E_{i,j}}\)</span> defines a static component of <span class="math notranslate nohighlight">\(H\)</span>,
<span class="math notranslate nohighlight">\(V_{i,j}^{\ell,n}\)</span> is the coupling between the states <span class="math notranslate nohighlight">\(i\)</span>
and <span class="math notranslate nohighlight">\(j\)</span> oscillating at frequency <span class="math notranslate nohighlight">\(n \omega_{\ell}\)</span> (i.e. the
<span class="math notranslate nohighlight">\(n\)</span>-th harmonic of the <span class="math notranslate nohighlight">\(\ell\)</span>-th fundamental frequency
<span class="math notranslate nohighlight">\(\omega_{\ell}\)</span>) and <span class="math notranslate nohighlight">\(N\)</span> is the number of incommensurate
frequencies.</p>
<p>To calculate the time-evolution operator we generalise the Rotating (or
Resonant) Wave Approximation (RWA), taking into account the complex time
dependence of Eq. (<a class="reference external" href="#eq:Hamiltonian">[eq:Hamiltonian]</a>). For this, we
rephrase the problem in terms of building a time-dependent unitary
transformation, <span class="math notranslate nohighlight">\(U_F(t)\)</span> to a new basis
<span class="math notranslate nohighlight">\(\{\left| \bar{i} \right\rangle\}\)</span>, that leads to a
<em>time-independent</em> and diagonal Hamiltonian, <span class="math notranslate nohighlight">\(\bar{H}\)</span>. The
operator <span class="math notranslate nohighlight">\(U_F(t)\)</span> is called the <em>micromotion operator</em> and the new
basis is a generalised multimode definition of the <em>dressed basis</em>.
After applying the standard quantum-mechanical transformation rule to
the Schrödinger equation
<a href="#id1"><span class="problematic" id="id2">:raw-latex:`\cite{chu1985recent,PhysRevA.81.063626}`</span></a>, this condition
becomes:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}  \begin{aligned}
   U_F^\dagger(t) \left[ H(t) - i \hbar \partial_t \right] U_F(t)  &amp;=&amp; \sum_{\bar{i}} \bar{E}_{\bar{i}} \left| \bar{i} \right\rangle \left\langle \bar{i} \right|
  \label{eq:Hdressed}\end{aligned}\\where :math:`\bar{E}_{\bar{i}}` is the eigen-energy of the dressed\end{aligned}\end{align} \]</div>
<p>state <span class="math notranslate nohighlight">\(\left| \bar{i} \right\rangle\)</span>, which is an eigenstate of
the static Hamiltonian <span class="math notranslate nohighlight">\(\bar{H}\)</span>.</p>
<p>Importantly, in the basis of states defined by this transformation the
time evolution operator is diagonal and has the form:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}  \bar{U}(t',t) = \sum_{\bar{i}} e^{-i \bar{E}_{\bar{i}} (t'-t)} \left| \bar{i} \right\rangle \left\langle \bar{i} \right|
  \label{eq:dressedtimeevolution}\\which let us to calculate the time evolution operator in the original\end{aligned}\end{align} \]</div>
<p>basis <span class="math notranslate nohighlight">\(\left\{ \left| i\right\rangle\right\}\)</span>, just by inverting
the transformation <span class="math notranslate nohighlight">\(U_F(t)\)</span>, according to
<a href="#id3"><span class="problematic" id="id4">:raw-latex:`\cite{PhysRevA.81.063626}`</span></a>:</p>
<div class="math notranslate nohighlight">
\[U(t',t) = U_F(t') \bar{U}(t',t) U_F(t)
\label{eq:baretimeevolution}\]</div>
<p>To formulate a fully defined computational problem, we express the
unitary transformation <span class="math notranslate nohighlight">\(U_F(t)\)</span> as the multifrequency Fourier
series <a href="#id5"><span class="problematic" id="id6">:raw-latex:`\cite{ho1983semiclassical}`</span></a>:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}  U_F(t) = \sum_{\vec{n}} U_{i,\bar{i}}^{\vec{n}} e^{-i\vec{\omega} \cdot \vec{n}t} \left| i \right\rangle \left\langle \bar{i} \right|
  \label{eq:micromotionexpansion}\\where :math:`\vec{\omega} = (\omega_1,\omega_2,\ldots,\omega_N)` and\end{aligned}\end{align} \]</div>
<p><span class="math notranslate nohighlight">\(\vec{n}\)</span> is a <span class="math notranslate nohighlight">\(N\)</span>-dimensional vector of integers. After
plugging this expansion in Eq. (<a class="reference external" href="#eq:Hdressed">[eq:Hdressed]</a>) and
performing an integral over time, we obtain a fully defined eigenproblem
for the eigenvalues <span class="math notranslate nohighlight">\(\bar{E}_{\bar{i}}\)</span> and Fourier components of
the unitary transformation <span class="math notranslate nohighlight">\(U_{i,\bar{E}}^{\vec{n}}\)</span>:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}  \sum_j(E_{i,j} - \hbar \vec{n} \cdot \vec{\omega})U^{\vec{n}}_{j,\bar{i}} + \sum_{j} \sum_{\vec{m}} \left[ V^{\vec{m}}_{i,j} U^{\vec{n}+\vec{m}}_{j,\bar{i}} + V^{\vec{m}*}_{ji} U^{\vec{m}-\vec{n}}_{j,\bar{i}}\right] = \bar{E}_{\bar{i}}U^{\vec{n}}_{i,\bar{i}}
  \label{eq:multimodeeigenproblem}\\where :math:`\vec{n}_{\ell,m} = \vec{n} + m P_{\ell}` with\end{aligned}\end{align} \]</div>
<p><span class="math notranslate nohighlight">\(P_{\ell} = (0,\ldots, 1, \ldots,0)\)</span> the projector at the
<span class="math notranslate nohighlight">\(\ell-\)</span>th position. To obtain a finite matrix representation of
this problem we truncate the sum over the number of modes of the Fourier
expansion Eq.
(<a class="reference external" href="#eq:micromotionexpansion">[eq:micromotionexpansion]</a>).</p>
<p>This formulation to calculate the time-evolution operator is equivalent
to the multimode Floquet representation of the Hamiltonian that
introduces an extended Hilbert space
<span class="math notranslate nohighlight">\(\left| E_i,\vec{n} \right\rangle\)</span>
<a href="#id7"><span class="problematic" id="id8">:raw-latex:`\cite{ho1983semiclassical,verdeny2016quasi}`</span></a>. However, the
semiclassical description presented here makes emphasis in the
physically accessible states.</p>
</div>
<div class="section" id="use-of-the-library">
<h1>Use of the library<a class="headerlink" href="#use-of-the-library" title="Permalink to this headline">¶</a></h1>
<p>Here we illustrate the use of the library’s functionality considering a
qubit driven by two harmonic forces. The Hamiltonian of this system has
the form:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}  H = \hbar \omega_0 S_z + \hbar \Omega_1 \cos(\omega_1 t) S_x + \hbar \Omega_{2,x} \cos(\omega_2 t) S_x + \hbar \Omega_{2,y} \cos(\omega_2 t)  S_z
  \label{eq:dressedqubitmodel}\\The Fortran and C++ source codes to find the time-evolution operator\end{aligned}\end{align} \]</div>
<p>are in the files:</p>
<ul class="simple">
<li>examples/FORTRAN/main_DressedQubit.f90 .</li>
<li>examples/CPP/main_dressedqubit.cpp .</li>
</ul>
<div class="section" id="declaration-of-the-hamiltonian-subsec-init">
<h2>Declaration of the Hamiltonian [subsec:init]<a class="headerlink" href="#declaration-of-the-hamiltonian-subsec-init" title="Permalink to this headline">¶</a></h2>
<p>First of all, we should declare the two derived types:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">TYPE</span><span class="p">(</span><span class="n">ATOM</span><span class="p">)</span>                                       <span class="n">ID</span>
<span class="n">TYPE</span><span class="p">(</span><span class="n">MODE</span><span class="p">),</span>       <span class="n">DIMENSION</span><span class="p">(:),</span>   <span class="n">ALLOCATABLE</span> <span class="p">::</span> <span class="n">FIELDS</span>
</pre></div>
</div>
<p>The variable ID contains information about the type of system, such as
the number of levels and their energy spectrum (see the declaration of
TYPE(ATOM) in Section <a class="reference external" href="#sec:derivedtypes">12</a>). The derived type
FIELDS stores information required to build the components of the
Hamiltonian as well as the explicit matrix representation of the
couplings.</p>
<p>In this concrete example, the components of ID are initialised by
calling the subroutine:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CALL</span> <span class="n">FLOQUETINIT</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span><span class="s1">&#39;qubit&#39;</span><span class="p">,</span><span class="n">INFO</span><span class="p">)</span>
</pre></div>
</div>
<p>The second argument indicates the type of system (here ’qubit’), which,
is sufficient to initialise the variable ID :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ID</span><span class="o">%</span><span class="n">id_system</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">ID</span><span class="o">%</span><span class="n">D_BARE</span>    <span class="o">=</span> <span class="mi">2</span>
</pre></div>
</div>
<p>where ID</p>
<p>Additional options of the function FLOQUETINIT are presented in section
<a class="reference external" href="#sec:InitOptions">5</a>, which are useful for initialising some
frequently used physical systems with default parameters. When dealing
with a general quantum system (i.e. with an arbitrary energy spectrum),
there is no need to call this function and the values of a variable of
TYPE(ATOM) must be initialised explicitly.</p>
<p>In the source code, the next relevant instruction is the definition of
an integer vector that provides information about the number of driving
frequencies. The integer array MODES_NUM is allocated with size 3,
indicating that the system will be driven by two fundamental frequencies
(corresponding to <span class="math notranslate nohighlight">\(\ell = 1,2\)</span> in Eq.
<a class="reference external" href="#eq:Hamiltonian">[eq:Hamiltonian]</a>), since the first component is
reserved to the static part of the Hamiltonian. The values of the
elements of this array indicate the number of driving harmonics of each
frequency, which here we set to <span class="math notranslate nohighlight">\(1\)</span> (making <span class="math notranslate nohighlight">\(n=1\)</span> in Eq.
<a class="reference external" href="#eq:Hamiltonian">[eq:Hamiltonian]</a>).</p>
<p>The total number of driving frequencies is equal to the sum of all
elements of the array MODES_NUM . The user then should allocate
sufficient memory space to store each one of the matrix representations
of the couplings <span class="math notranslate nohighlight">\(V^{\ell,n}\)</span>. This is done with the sequence of
instructions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">TOTAL_FREQUENCIES</span> <span class="o">=</span> <span class="n">SUM</span><span class="p">(</span><span class="n">MODES_NUM</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ALLOCATE</span><span class="p">(</span><span class="n">FIELDS</span><span class="p">(</span><span class="n">TOTAL_FREQUENCIES</span><span class="p">))</span>
<span class="n">DO</span> <span class="n">m</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">TOTAL_FREQUENCIES</span>
   <span class="n">ALLOCATE</span><span class="p">(</span><span class="n">FIELDS</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="o">%</span><span class="n">V</span><span class="p">(</span><span class="n">ID</span><span class="o">%</span><span class="n">D_BARE</span><span class="p">,</span><span class="n">ID</span><span class="o">%</span><span class="n">D_BARE</span><span class="p">))</span>
<span class="n">END</span> <span class="n">DO</span>
</pre></div>
</div>
<p>By default the first element of the array of FIELDS is reserved for the
static component of the Hamiltonian, which includes the spectrum of the
static system as diagonal elements of the matrix FILEDS(1).</p>
<p>When dealing with spin systems, as in the present example, each
component of the Hamiltonian can be written as:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}  V^{\ell,n} = e^{\phi_x} X S_x + e^{\phi_y} Y S_y + e^{\phi_z} Z S_z
  \label{eq:Vspinparametrisation}\\where :math:`S_i` is the angular momentum operator. Therefore, we need\end{aligned}\end{align} \]</div>
<p>only six parameters (three phases and three amplitudes) to define the
coupling matrices.</p>
<p>These six parameters should be declared explicitly for each one of the
the driving modes, along with the frequency ( omega ) and the
corresponding number of modes to be included in the Fourier expansion of
the evolution operator ( N_Floquet ). The values of these parameters are
initialised as follows:</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Source code</th>
<th class="head">Parameter in Eq.
(<a class="reference external" href="#eq:Vspinparametrisation">[eq:Vspinparametrisation]</a>)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>FIELDS(1) FIELDS(1) FIELDS(1)
FIELDS(1) FIELDS(1) FIELDS(1)
FIELDS(1) FIELDS(1)</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>where we have a direct correspondence with Eq.
(<a class="reference external" href="#eq:Vspinparametrisation">[eq:Vspinparametrisation]</a>). This set of
instructions is repeated for each one of the driving fields, as can be
seen in the source code.</p>
</div>
<div class="section" id="hamiltonian-components">
<h2>Hamiltonian components<a class="headerlink" href="#hamiltonian-components" title="Permalink to this headline">¶</a></h2>
<p>The instructions detailed before let us to build the matrix
representation of the terms in Eq.
(<a class="reference external" href="#eq:Vspinparametrisation">[eq:Vspinparametrisation]</a>). This is done
simply by calling the subroutine:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CALL</span>  <span class="n">SETHAMILTONIANCOMPONENTS</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span><span class="n">size</span><span class="p">(</span><span class="n">modes_num</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">total_frequencies</span><span class="p">,</span><span class="n">MODES_NUM</span><span class="p">,</span><span class="n">FIELDS</span><span class="p">,</span><span class="n">INFO</span><span class="p">)</span>
</pre></div>
</div>
<p>which results in storing the coupling <span class="math notranslate nohighlight">\(V^{\ell,n}\)</span> in the set of
matrices FIELDS(r)</p>
<p>We remind the user that when the system of interest is not one of the
default types defined in section <a class="reference external" href="#subsec:init">[subsec:init]</a>, the
user must define explicitly and in full all the coupling matrices. For
an example of this situation, see the source file
example/FORTRAN/main_lattice.f90 .</p>
</div>
<div class="section" id="multimode-floquet-matrix-and-diagonalisation">
<h2>Multimode Floquet matrix and diagonalisation<a class="headerlink" href="#multimode-floquet-matrix-and-diagonalisation" title="Permalink to this headline">¶</a></h2>
<p>Once the components of the Hamiltonian are defined (i.e the complete set
of matrices FIELDS(r)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CALL</span> <span class="n">MULTIMODEFLOQUETMATRIX</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span><span class="n">size</span><span class="p">(</span><span class="n">modes_num</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">total_frequencies</span><span class="p">,</span><span class="n">MODES_NUM</span><span class="p">,</span><span class="n">FIELDS</span><span class="p">,</span><span class="n">INFO</span><span class="p">)</span>
</pre></div>
</div>
<p>As a result of this call, the system stores the full multimode Floquet
matrix on the left-hand side of Eq.
(<a class="reference external" href="#eq:multimodeeigenproblem">[eq:multimodeeigenproblem]</a>) in the
matrix H_FLOQUET. This matrix is defined in the module ARRAYS and can be
accessed (and modified!) by all computational routines that include this
module. The size of this matrix is calculated internally and stored in
the parameter h_floquet_size , which is also a global variable.</p>
<p>The library includes a subroutine to evaluate a sparse representation of
this matrix, which results after invoking:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CALL</span> <span class="n">MULTIMODEFLOQUETMATRIX_SP</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span><span class="n">SIZE</span><span class="p">(</span><span class="n">MODES_NUM</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">total_frequencies</span><span class="p">,</span>
                               <span class="n">MODES_NUM</span><span class="p">,</span><span class="n">FIELDS</span><span class="p">,</span><span class="n">VALUES</span><span class="p">,</span><span class="n">ROW_INDEX</span><span class="p">,</span><span class="n">COLUMN</span><span class="p">,</span><span class="n">INFO</span><span class="p">)</span>
</pre></div>
</div>
<p>Setting INFO = 0, this instruction produces the representation of the
Floquet matrix H_FLOQUET in the three array variation of the Compressed
Sparse Row (CSR) storage format. With INFO=6, we get the matrix stored
as three arrays of equal length, corresponding to values, rows and
columns positions. The non-zero values of the matrix are stored in the
complex array VALUES , and the information about their location is
encoded in the integer arrays COLUMN and ROW_INDEX . The size of these
three arrays are evaluated internally.</p>
<p>The library includes wrappers to diagonalisation subroutines from the
Lapack and the MKL-intel (for the sparse CSR representation) libraries.
These functions are called using:</p>
<p>Lapack :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CALL</span>  <span class="n">LAPACK_FULLEIGENVALUES</span><span class="p">(</span><span class="n">U_F</span><span class="p">,</span><span class="n">SIZE</span><span class="p">(</span><span class="n">H_FLOQUET</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">E_FLOQUET</span><span class="p">,</span><span class="n">INFO</span><span class="p">)</span>
</pre></div>
</div>
<p>MKL:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CALL</span> <span class="n">MKLSPARSE_FULLEIGENVALUES</span><span class="p">(</span><span class="n">D_MULTIFLOQUET</span><span class="p">,</span><span class="n">SIZE</span><span class="p">(</span><span class="n">VALUES</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">VALUES</span><span class="p">,</span><span class="n">ROW_INDEX</span><span class="p">,</span>
                                                    <span class="n">COLUMN</span><span class="p">,</span><span class="n">E_L</span><span class="p">,</span><span class="n">E_R</span><span class="p">,</span><span class="n">E_FLOQUET</span><span class="p">,</span><span class="n">U_F</span><span class="p">,</span><span class="n">INFO</span><span class="p">)</span>
</pre></div>
</div>
<p>In both cases, the eigenvalues are stored in the array E_FLOQUET and the
eigenvectors are stored as columns of the matrix U_F. Remember that
these eigenvectors correspond to the coefficients of the multimode
Fourier decomposition of the micromotion operator Eq.
(<a class="reference external" href="#eq:micromotionexpansion">[eq:micromotionexpansion]</a>). Invoking the
MKL subroutine requires two additional parameter E_L and E_R : the lower
and upper bounds of the interval to be searched for eigenvalues,
respectively. The user is responsible to set meaningful values of both
parameters.</p>
<p>The MKL sparse solvers requires the use of the variation of the
Compressed sparse row (CSR) representation of the matrix, which is
produced by sorting the array of ROW position, in such a way that all
non-zero values of a given row become stored consecutively. This sorting
is done using a QUICK_SORT algorithm by Robert Renka (OAK Ridge Natl.
Lab, US) accessible from the Alan Miller’s Fortran Software website
<a href="#id9"><span class="problematic" id="id10">:raw-latex:`\cite{MillerSoftware}`</span></a>. Alternatively, calling the function
MULTIMODEFLOQUETMATRIX_SP with the variable INFO=6 , the user obtains
the extended Hamiltonian represented by the three arrays of value,
column, row , which can be used with a different eigenvalue solver for
sparse matrices.</p>
</div>
<div class="section" id="time-evolution-operator">
<h2>Time-evolution operator<a class="headerlink" href="#time-evolution-operator" title="Permalink to this headline">¶</a></h2>
<p>With the full spectrum of H_FLOQUET , the time evolution operator
between T1 and T2 , corresponding to Eq.
(<a class="reference external" href="#eq:baretimeevolution">[eq:baretimeevolution]</a>), can be evaluated
calling the function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CALL</span> <span class="n">MULTIMODETIMEEVOLUTINOPERATOR</span><span class="p">(</span><span class="n">SIZE</span><span class="p">(</span><span class="n">U_F</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">SIZE</span><span class="p">(</span><span class="n">MODES_NUM</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">MODES_NUM</span><span class="p">,</span><span class="n">U_F</span><span class="p">,</span><span class="n">E_FLOQUET</span><span class="p">,</span>
                                                          <span class="n">ID</span><span class="o">%</span><span class="n">D_BARE</span><span class="p">,</span><span class="n">FIELDS</span><span class="p">,</span><span class="n">T1</span><span class="p">,</span><span class="n">T2</span><span class="p">,</span><span class="n">U_AUX</span><span class="p">,</span><span class="n">INFO</span><span class="p">)</span>
</pre></div>
</div>
<p>which produces the matrix representation of the operator in Eq.
(<a class="reference external" href="#eq:baretimeevolution">[eq:baretimeevolution]</a>). The time evolution
operator is stored in the complex matrix U_AUX , whose size is equal to
the number of bare states ID</p>
</div>
<div class="section" id="micromotion-operator">
<h2>Micromotion operator<a class="headerlink" href="#micromotion-operator" title="Permalink to this headline">¶</a></h2>
<p>The micromotion operator is the time-dependent unitary transformation
between the bare basis and the basis of state where the Hamiltonian is
time-independent. Since we know the Fourier decomposition of this
transformation via the diagonalisation of H_FLOQUET , we can evaluate
the instantaneous transformation, e.g. at time T1, using the subroutine:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CALL</span> <span class="n">MULTIMODEMICROMOTION</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span><span class="n">SIZE</span><span class="p">(</span><span class="n">U_F</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">NM</span><span class="p">,</span><span class="n">MODES_NUM</span><span class="p">,</span><span class="n">U_F</span><span class="p">,</span><span class="n">E_FLOQUET</span><span class="p">,</span><span class="n">ID</span><span class="o">%</span><span class="n">D_BARE</span><span class="p">,</span>
                                                              <span class="n">FIELDS_</span><span class="p">,</span><span class="n">T1</span><span class="p">,</span><span class="n">U_F1</span><span class="p">,</span><span class="n">INFO</span><span class="p">)</span>
</pre></div>
</div>
<p>which produces the matrix representation of the operator in Eq.
(<a class="reference external" href="#eq:micromotionexpansion">[eq:micromotionexpansion]</a>). This
micromotion operator is stored in the square matrix U_F1 of size ID</p>
</div>
<div class="section" id="identifying-the-dressing-modes">
<h2>Identifying the dressing modes<a class="headerlink" href="#identifying-the-dressing-modes" title="Permalink to this headline">¶</a></h2>
<p>In several applications is useful to define a dressed basis of states
and the openMMF library includes functions to simplify the evaluation of
the evolution operator in this basis. For this, first the user should
identify the subset of driving fields that define the dressed states.
This is done using an integer array with as a many components as
dressing fields. The elements of this array indicate the indices of the
fields corresponding to the array MODES_NUM . For example, if there is
only one dressing field and it corresponds to the second component of
the array MODES_NUM, then the array that indicates the dressing field,
DRESSINFIELDS_INDICES , must be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>INTEGER, DIMENSION(2) :: DRESSINGFIELDS_INDICES
DRESSINGFIELDS_INDICES(1) = 1 ! THE STATIC COMPONEN
DRESSINGFIELDS_INDICES(2) = 2 ! THE FIRST DRIVING FIELD, WHICH DRESSES THE SYSTEM
</pre></div>
</div>
<p>With this, the Fourier decomposition of the micromotion operator
defining the dressed basis in Eq.
(<a class="reference external" href="#eq:micromotionexpansion">[eq:micromotionexpansion]</a>), can be
obtained simply by calling the function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CALL</span> <span class="n">MICROMOTIONFOURIERDRESSEDBASIS</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span><span class="n">DRESSINGFIELDS_INDICES</span><span class="p">,</span><span class="n">MODES_NUM</span><span class="p">,</span>
                                                    <span class="n">FIELDS</span><span class="p">,</span><span class="n">U_FD</span><span class="p">,</span><span class="n">E_DRESSED</span><span class="p">,</span><span class="n">INFO</span><span class="p">)</span>
</pre></div>
</div>
<p>The Fourier components <span class="math notranslate nohighlight">\(U_{i,\bar{i}}^{\vec{n}}\)</span> are stored in the
matrix U_FD and the spectrum of dressed energies,
<span class="math notranslate nohighlight">\(\bar{E}_{\bar{i}}\)</span>, are stored in the array E_DRESSED . With
these two elements, we can calculate the micromotion operator of the
dressed basis using the subroutine:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CALL</span> <span class="n">MICROMOTIONDRESSEDBASIS</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span><span class="n">MODES_NUM</span><span class="p">,</span><span class="n">DRESSINGFIELDS_INDICES</span><span class="p">,</span><span class="n">FIELDS</span><span class="p">,</span><span class="n">U_FD</span><span class="p">,</span>
                                                            <span class="n">E_DRESSED</span><span class="p">,</span><span class="n">T1</span><span class="p">,</span><span class="n">U_FD_1</span><span class="p">,</span><span class="n">INFO</span><span class="p">)</span>
</pre></div>
</div>
<p>The micromotion operator at T1 is then stored as the square matrix
U_FD&nbsp;. This set of instructions let us to evaluate the time-evolution
operator in the dressed basis using the sequence:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>CALL MICROMOTIONDRESSEDBASIS(ID,MODES_NUM,DRESSINGFIELDS_INDICES,FIELDS,U_FD,
                                                          E_DRESSED,T1,U_F1,INFO)
CALL MICROMOTIONDRESSEDBASIS(ID,MODES_NUM,DRESSINGFIELDS_INDICES,FIELDS,U_FD,
                                                          E_DRESSED,T2,U_F2,INFO)

! ---- CALCULATE THE TIME-EVOLUTION OPERATOR IN THE DRESSED
! ---- BASIS USING THE PREVIOUSLY CALCULATED IN THE BARE BASIS

U_AUX = MATMUL(TRANSPOSE(CONJG(U_F2)),MATMUL(U_AUX,U_F1))
</pre></div>
</div>
</div>
</div>
<div class="section" id="typical-performance">
<h1>Typical performance<a class="headerlink" href="#typical-performance" title="Permalink to this headline">¶</a></h1>
<p>The efficiency of the library is limited by the capability to solve the
eigenvalue problem of the multimode Floquet Hamiltonian. Fig.
<a class="reference external" href="#fig:performance">[fig:performance]</a>(a) compares the execution
times for a single diagonalisation of the Floquet HamiltonianBosonic and
Fermionic Hubbard models, as functions of the size of the matrix (red
and blue data/lines). The source codes can be found in
examples/FORTRAN/MANYBODYHUBBARD/ and the model Hamiltonian are:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}  \begin{aligned}
  H_{Bosons}(t)   &amp;=&amp;  (t+ \Delta t \cos(\omega t + \phi))\sum_{&lt;i,j&gt;}   b_i b_j^\dagger  + \frac{u}{2}\sum_j  n_j(n_j-1) \nonumber \\
  H_{Fermions}(t) &amp;=&amp;   (t+ \Delta t \cos(\omega t + \phi)) \sum_{i,\sigma} (f_{i,\sigma} f_{i+1,\sigma}^\dagger +  f_{i+1,\sigma}^\dagger f_{i,\sigma})  + u \sum_j n_{j,\uparrow} n_{j,\downarrow} \nonumber \end{aligned}\end{split}\\and we use the parameters\end{aligned}\end{align} \]</div>
<p><span class="math notranslate nohighlight">\(t=1, u=0.5, \phi = 0.0, \omega = 1.0, \Delta t = 0.2\)</span>. To vary
the size of the Floquet Hamiltonian we increase the number of Floquet
manifolds.</p>
<p>For these tests, the library performs two tasks: evaluates the Floquet
Hamiltonian and use LAPACK to obtain the spectrum (only once for each
matrix size). The Hamiltonian corresponds to a periodically driven
Hubbard model (with near-neighbour tunnelling and on-site interaction)
and the matrix dimension is given by the number of Floquet manifolds.</p>
<p>Figure <a class="reference external" href="#fig:performance">[fig:performance]</a>(b) shows the execution
time required to evaluate a single time-step of the time-evolution
operator of driven qubit with a noisy background. The Hamiltonian of
this system is:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}H = \hbar \omega_0 S_z + \hbar \Omega S_x \cos (\omega t + \phi) + \sum_\ell^N \Delta_i \cos(\ell \omega/N t + \phi_i)\\with :math:`N` the number of frequencies contributing to the noisy\end{aligned}\end{align} \]</div>
<p>field, <span class="math notranslate nohighlight">\(\Delta_i\)</span> and <span class="math notranslate nohighlight">\(\phi_i\)</span> random amplitudes and phases,
respectively. With this, the noise frequency is limited up to the
driving frequency <span class="math notranslate nohighlight">\(\omega\)</span>. The matrix size reflects the number of
components of the noisy driving.</p>
<p>In this case we use a DRIVER subroutine and build a sparse
representation of the multimode Hamiltonian. In contrast to the previous
test, we observe that the matrix building and diagonalisation take about
the same fraction of the total time. However, a direct comparison of the
total times between these two examples is not straightforward since the
structure of the Floquet matrix of the two problems is significantly
different.</p>
<p>These results give us a rough idea of the scaling of the execution time
with the matrix size, as well as the possible performance bottlenecks.
These tests were performed using a DELL XPS with an Intel Core i7 vPro &#64;
2.7 GHz and 8GB of RAM. The machine runs on Linux Mint 17.2 Rafaela,
with gcc-4.9.4</p>
</div>
<div class="section" id="default-system-types">
<span id="sec-initoptions"></span><h1>Default system types<a class="headerlink" href="#default-system-types" title="Permalink to this headline">¶</a></h1>
<p>The openMMF library defines three different system types by default.
These are Qubit, Spin and the ground state of several alkali atoms. A
general system with <span class="math notranslate nohighlight">\(D\)</span> energy leveles can be defined using the
“spin” type and setting by hand all coupling matrices.</p>
<div class="section" id="qubit">
<h2>Qubit<a class="headerlink" href="#qubit" title="Permalink to this headline">¶</a></h2>
<p>This type represents a two level system, where the couplings with the
oscillating field are of the form</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}V^{\ell,n} = X S_x e^{\phi_{\ell,x}} +  Y S_y e^{\phi_{\ell,y}} + Y S_z e^{\phi_{\ell,z}}\\with :math:`S_i, i\in{x,y,z}` the set of spin :math:`1/2` angular\end{aligned}\end{align} \]</div>
<p>momentum operators with <span class="math notranslate nohighlight">\(\hbar := 1\)</span>.</p>
<p>The corresponding derived type is initialised with the instruction:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FLOQUET_INIT</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span><span class="s1">&#39;qubit&#39;</span><span class="p">,</span><span class="n">INFO</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="spin-of-total-angular-momentum-s-z">
<h2>Spin of total angular momentum <span class="math notranslate nohighlight">\(S_z\)</span><a class="headerlink" href="#spin-of-total-angular-momentum-s-z" title="Permalink to this headline">¶</a></h2>
<p>This type represents a system with <span class="math notranslate nohighlight">\(2 S_z + 1\)</span> equally space
energy levels, where the couplings with oscillating fields are of the
form:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}V^{\ell,n} = X S_x e^{\phi_{\ell,x}} +  Y S_y e^{\phi_{\ell,y}} + Y S_z e^{\phi_{\ell,z}}\\with :math:`S_i, i\in{x,y,z}` the set of angular momentum operators\end{aligned}\end{align} \]</div>
<p>with total spin <span class="math notranslate nohighlight">\(S_z\)</span>.</p>
<p>The corresponding derived type is initialised with the instruction:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FLOQUET_INIT</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span><span class="s1">&#39;spin&#39;</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">Sz</span><span class="p">,</span><span class="n">INFO</span><span class="p">)</span>
</pre></div>
</div>
<p>where the third argument is a DOUBLE PRECISION variable equal to the
double of the projection of the total angular momentum.</p>
<p>The matrix representation of the angular momentum operators <span class="math notranslate nohighlight">\(s_i\)</span>
is build using <a href="#id11"><span class="problematic" id="id12">:raw-latex:`\cite{sakurai1995modern}`</span></a>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\left\langle S, m'\right| S_x \left| S,m\right\rangle&amp;=&amp; \frac{1}{2} \left[\sqrt{(S-m)(S+m+1)}\delta_{m,m'+1} + \sqrt{(S+m)(S-m+1)}\delta_{m,m'-1} \right]  \label{eq:S_x}\\
\left\langle S, m'\right| S_y \left| S,m\right\rangle&amp;=&amp; \frac{i}{2} \left[\sqrt{(S-m)(S+m+1)}\delta_{m,m'+1} - \sqrt{(S+m)(S-m+1)}\delta_{m,m'-1} \right]  \label{eq:S_y}\\
\left\langle S, m'\right| S_z \left| S,m\right\rangle&amp;=&amp; m\delta_{m,m'} \label{eq:S_z} \end{aligned}\end{split}\]</div>
</div>
<div class="section" id="ground-state-alkali-atoms">
<h2>Ground state Alkali atoms.<a class="headerlink" href="#ground-state-alkali-atoms" title="Permalink to this headline">¶</a></h2>
<p>The effective model of an alkali atom consist of an electron with zero
orbital angular momenta interacting with a static nucleus. These two
particles interact via their magnetic moments, which define two
manifolds of states corresponding to the total angular momenta
<span class="math notranslate nohighlight">\(F=I\pm1/2\)</span>. The library can be used to study inter and intra
manifold dynamics.</p>
<p>For example, to study the dynamics with focus on the manifold with total
angular momentum <span class="math notranslate nohighlight">\(F=I-1/2\)</span> (’L’, for lower), the corresponding ID
can be obtained by invoking:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CALL</span> <span class="n">FLOQUET_INIT</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span><span class="n">SPECIE_NAME</span><span class="p">,</span><span class="s1">&#39;L&#39;</span><span class="p">,</span><span class="n">INFO</span><span class="p">)</span>
</pre></div>
</div>
<p>and the Hamiltonian components are built assuming the form:</p>
<div class="math notranslate nohighlight">
\[V^{\ell,n} = \frac{\mu_B g_{I-1/2} B_x}{A} F_x e^{\phi_{\ell,x}} +  \frac{\mu_B g_{I-1/2} B_y}{A} F_y e^{\phi_{\ell,y}} + \frac{\mu_B g_{I-1/2} B_z}{A} F_z e^{\phi_{\ell,z}}\]</div>
<p>Similarly, to study the dynamic of the manifold with <span class="math notranslate nohighlight">\(F=I+1/2\)</span>
(’U’, for upper), the system is initialised using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CALL</span>  <span class="n">FLOQUET_INIT</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span><span class="n">SPECIE_NAME</span><span class="p">,</span><span class="s1">&#39;U&#39;</span><span class="p">,</span><span class="n">INFO</span><span class="p">)</span>
</pre></div>
</div>
<p>which assumes couplings of the form</p>
<div class="math notranslate nohighlight">
\[V^{\ell,n} = \frac{\mu_B g_{I+1/2} B_x}{A} F_x e^{\phi_{\ell,x}} +  \frac{\mu_B g_{I+1/2} B_y}{A} F_y e^{\phi_{\ell,y}} + \frac{\mu_B g_{I+1/2} B_z}{A} F_z e^{\phi_{\ell,z}}\]</div>
<p>The atomic gyromagnetic factor is defined by:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}g_F = g_J*(F*(F+1) - I*(I+1) +J*(J+1))/(2*F*(F+1)) + g_I*(F*(F+1) + I*(I+1) - J*(J+1))/(2*F*(F+1))!\\with :math:`F=I \pm 1/2`. The matrix representation in each case\end{aligned}\end{align} \]</div>
<p>follows the same procedure as in the case of a spin system.</p>
<p>Finally, when both manifolds are of interest, we should use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CALL</span> <span class="n">FLOQUET_INIT</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span><span class="n">SPECIE_NAME</span><span class="p">,</span><span class="s1">&#39;B&#39;</span><span class="p">,</span><span class="n">INFO</span><span class="p">)</span>
</pre></div>
</div>
<p>which prepares the system to initialise couplings of the form:</p>
<div class="math notranslate nohighlight">
\[V^{\ell,n} = \frac{\mu_B  B_x}{A} (g_J J_x + g_I I_x) e^{\phi_{\ell,x}} +  \frac{\mu_B B_y}{A} (g_J J_y + g_I I_y) e^{\phi_{\ell,y}} + \frac{\mu_B B_z}{A} (g_J J_z + g_I I_z) e^{\phi_{\ell,z}}\]</div>
<p>In this case, the angular momentum operators are represented in the
uncoupled basis <span class="math notranslate nohighlight">\(\left| I,J,m_I,m_J \right\rangle\)</span>, corresponding
to a tensor multiplication of the matrices resulting from Eqs.
(<a class="reference external" href="#eq:S_x">[eq:S_x]</a>)-(<a class="reference external" href="#eq:S_z">[eq:S_z]</a>) representing
<span class="math notranslate nohighlight">\(I_i\)</span> and <span class="math notranslate nohighlight">\(J_i\)</span>.</p>
<p>In all these cases, after invoking the initialisation routine
FLOQUET_INIT and defining the parameters of the couplings using the
derived data type TYPE(MODES)::FIELDS, the matrix representation of each
component of the Hamiltonian can be obtained with a single call to the
subroutine:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CALL</span> <span class="n">SETHAMILTONIANCOMPONENTS</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span><span class="n">size</span><span class="p">(</span><span class="n">modes_num</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">total_frequencies</span><span class="p">,</span><span class="n">MODES_NUM</span><span class="p">,</span><span class="n">FIELDS</span><span class="p">,</span><span class="n">INFO</span><span class="p">)</span>
</pre></div>
</div>
<p>where total_frequencies is the total number of driving fields (including
a static component). For a complete example see the source code at
examples/FORTRAN/main_87Rb.f90 .</p>
</div>
</div>
<div class="section" id="list-of-examples">
<h1>List of examples<a class="headerlink" href="#list-of-examples" title="Permalink to this headline">¶</a></h1>
<div class="section" id="python">
<h2>Python<a class="headerlink" href="#python" title="Permalink to this headline">¶</a></h2>
<p>Build the examples running make in the folder examples/PYTHON .</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>main_87Rb.py</td>
<td>Evaluates the time-evolution and
spectrum of a driven atom of
87Rb.</td>
</tr>
<tr class="row-even"><td>main_DressedQubit.py</td>
<td>Evaluates the time evolution of a
dressed qubit in the bare and
dressed basis.</td>
</tr>
<tr class="row-odd"><td>main_floquetinit.py</td>
<td>Illustrates the optional systems.</td>
</tr>
<tr class="row-even"><td>main_qubit_driver.py</td>
<td>Evaluates the tim-evolution
operator of a driven qubit using
a DRIVER subroutine.</td>
</tr>
<tr class="row-odd"><td>main_qubit.py</td>
<td>Evaluates the time-evolution
operator of a driven qubit.</td>
</tr>
<tr class="row-even"><td>main_qubit_sp.py</td>
<td>Evaluatese the time-evolution
operator of driven qubit using
the sparse representation of the
Hamiltonian.</td>
</tr>
<tr class="row-odd"><td>openmmf.py</td>
<td>Defines the Python wrappers.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="c">
<h2>C++<a class="headerlink" href="#c" title="Permalink to this headline">¶</a></h2>
<p>Build the examples running make in the folder examples/CPP .</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>main_DressedQubit.cpp</td>
<td>Evaluates the time evolution of a
dressed qubit in the bare and
dressed basis.</td>
</tr>
<tr class="row-even"><td>main_DressedQubit_SP.cpp</td>
<td>Evaluates the time evolution of a
dressed qubit in the bare and
dressed basis using the sparse
representation of the
Hamiltonnian.</td>
</tr>
<tr class="row-odd"><td>main_qubit_driver.cpp</td>
<td>Evaluates the tim-evolution
operator of a driven qubit using
a DRIVER subroutine.</td>
</tr>
<tr class="row-even"><td>main_qubit.cpp</td>
<td>Evaluates the time-evolution
operator of a driven qubit.</td>
</tr>
<tr class="row-odd"><td>main_qubit_sp.cpp</td>
<td>Evaluatese the time-evolution
operator of driven qubit using
the sparse representation of the
Hamiltonian.</td>
</tr>
<tr class="row-even"><td>MultimodeFloquet.h</td>
<td>Prototype of the C++ wrapper
functios.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="fortran">
<h2>Fortran<a class="headerlink" href="#fortran" title="Permalink to this headline">¶</a></h2>
<p>Build the examples running make in the folder examples/FORTRAN .</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>main_qubit_Shirley.f90</td>
<td>Evaluates the time-evolution
operator of a driven qubit with
parameters as in the classical
paper by Jon Shirley.</td>
</tr>
<tr class="row-even"><td>main_qubit.f90</td>
<td>Evaluates the time-evolution
operator of a driven qubit.</td>
</tr>
<tr class="row-odd"><td>main_qubit_SP.f90</td>
<td>Evaluatese the time-evolution
operator of driven qubit using
the sparse representation of the
Hamiltonian.</td>
</tr>
<tr class="row-even"><td>main_qubit_DRIVER.f90</td>
<td>Evaluates the tim-evolution
operator of a driven qubit using
a DRIVER subroutine.</td>
</tr>
<tr class="row-odd"><td>main_QuantumInterference.f90</td>
<td>Evaluates the time-evolution of a
bichromatically driven qubit.</td>
</tr>
<tr class="row-even"><td>main_qubit_noise_SP.f90</td>
<td>Evaluates the time-evolution
operator of a driven qubit ina
noisy environment. Uses a sparse
representation of the
Hamiltonian.</td>
</tr>
<tr class="row-odd"><td>main_halfspin_DRIVER.f90</td>
<td>Evaluates the time-evolution
operator of a two-level system
(defined with ’spin’) using a
DRIVER subroutine,</td>
</tr>
<tr class="row-even"><td>main_spin_DRIVER.f90</td>
<td>Evaluates the time-evolution
operator of a L-level system
(defined with ’spin’) using a
DRIVER subroutine,</td>
</tr>
<tr class="row-odd"><td>main_lattice.f90</td>
<td>evaluates the spectrum and
micromotion of a driven lattice
with two sites in the unit cell.</td>
</tr>
<tr class="row-even"><td>main_threesiteslattice.f90</td>
<td>evaluates the spectrum and
micromotion of a driven lattice
with three sites in the unit
cell.</td>
</tr>
<tr class="row-odd"><td>main_qubitLattice.f90</td>
<td>Evaluates the time-evolution of a
bichromatically driven qubit as
in Eq. (20), arxiv 1612.02143.</td>
</tr>
<tr class="row-even"><td>main_qubitLattice_SP.f90</td>
<td>Evaluates the time-evolution of a
bichromatically driven qubit as
in Eq. (20), arxiv 1612.02143,
using a sparse representation of
the Hamiltonian.</td>
</tr>
<tr class="row-odd"><td>main_qubitLattice_DRIVER.f90</td>
<td>Evaluates the time-evolution of a
bichromatically driven qubit as
in Eq. (20), arxiv 1612.02143,
using a DRIVER subroutine.</td>
</tr>
<tr class="row-even"><td>main_DressedQubit.f90</td>
<td>Evaluates the time evolution of a
dressed qubit in the bare and
dressed basis.</td>
</tr>
<tr class="row-odd"><td>main_DressedQubitV2.f90</td>
<td>Evaluates the time evolution of a
dressed qubit in the bare and
dressed basis.</td>
</tr>
<tr class="row-even"><td>main_DressedQubit_SP.f90</td>
<td>Evaluates the time evolution of a
dressed qubit in the bare and
dressed basis using the sparse
representation of the
Hamiltonnian.</td>
</tr>
<tr class="row-odd"><td>main_DressedQubit_DRIVER.f90</td>
<td>Evaluates the time evolution of a
dressed qubit in the bare and
dressed basis using a DRIVER
subroutine..</td>
</tr>
<tr class="row-even"><td>main_87Rb_RFMW_DRIVER.f90</td>
<td>Evaluates the time-evolution
operator of 87Rb dressed by a RF
field and driven by a MW field,
using the dressed basis.</td>
</tr>
<tr class="row-odd"><td>DoublePeakSearch.f90</td>
<td>Evaluates the time-evolution
operator of 87Rb dressed by a RF
field and driven by a MW field,
using the dressed basis.</td>
</tr>
<tr class="row-even"><td>Manybody/main_MBH_Bosons.f90</td>
<td>Evaluates the spectrum of the
Bosonic Hubbard model with
time-dependent tunnelling.</td>
</tr>
<tr class="row-odd"><td>Manybody/main_MBH_Fermions.f90</td>
<td>Evaluates the spectrum of the
Fermionic Hubbard model with
time-dependent tunnelling.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="c-wrappers">
<h1>C++ wrappers<a class="headerlink" href="#c-wrappers" title="Permalink to this headline">¶</a></h1>
<p>The library includes C++ interfaces for each one of the subroutines
defined. These interfaces are declared in files with the same name as
the ones containing the Fortran declarations, but with the particle _C
appended before the ending extension .f90 . Similarly, wrapper
subroutine are named using the corresponding Fortran names and appending
the particle _c at the end of the name. For example, the file
MultimodeFloquetTE_C.f90 is paired with the file MultimodeFloquet.f90
and defines the subroutine MULTIMODETIMEEVOLUTIONOPERATOR_C , which is
used in c++ using multimodetimeevolutionoperator_c_ followed by the
declared list of arguments (see example at examples/CPP/main_qubit.cpp .</p>
<p>The prototype of all function enabled for C++ are declared in the header
file include/MultimodeFloquet.h . This scheme lets us to establish a
line-by-line correspondence between the Fortran and C++ source codes.</p>
</div>
<div class="section" id="python-wrappers">
<h1>Python wrappers<a class="headerlink" href="#python-wrappers" title="Permalink to this headline">¶</a></h1>
<p>The library includes an interface to Python, which is implemented using
CTYPES. Similarly to the C++ wrappers, for Python we define a function
for each one of the functionalities of the library. This set of
functions is declared in the file src/openmmf.py , which should be
copied to the python working directory. The Python wrappers call the C++
wrappers which are compiled in the file libmultimodefloquet.so. The user
should make sure that the correct path to this file is set in
src/openmmf.py .</p>
<p>The python wrapper requires to define the equivalent ot the atom and
mode derived data types, which are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">atom_c_T</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="s2">&quot;id_system&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;d_bare&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)</span>
            <span class="p">]</span>
</pre></div>
</div>
<p>and</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">mode_c_T</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">c_dcmplx</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="o">*</span><span class="mi">2</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="s2">&quot;omega&quot;</span><span class="p">,</span>     <span class="n">c_double</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span>         <span class="n">c_dcmplx</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span>         <span class="n">c_dcmplx</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,</span>         <span class="n">c_dcmplx</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;phi_x&quot;</span><span class="p">,</span>     <span class="n">c_double</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;phi_y&quot;</span><span class="p">,</span>     <span class="n">c_double</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;phi_z&quot;</span><span class="p">,</span>     <span class="n">c_double</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;N_Floquet&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)</span>
            <span class="p">]</span>
</pre></div>
</div>
<p>respectively.</p>
<p>Each python wrapper function in src/openmmf.py takes numpy input
parameters and define the set of ctype pointers required to call the
corresponding C++ wrapper function. Let’s examine the instruction to
build the multimode Floquet Hamiltonian:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">multimodefloquetmatrix</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">modes_num</span><span class="p">,</span><span class="n">fields</span><span class="p">,</span><span class="n">info</span><span class="p">):</span>

    <span class="n">id_p</span>              <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="n">nm</span>                <span class="o">=</span> <span class="n">c_int</span><span class="p">(</span><span class="n">modes_num</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="n">total_frequencies</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">modes_num</span><span class="p">))</span>
    <span class="n">info</span>              <span class="o">=</span> <span class="n">c_int</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
    <span class="n">modes_num_p</span>       <span class="o">=</span> <span class="n">modes_num</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
    <span class="n">fields_p</span>          <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span>
    <span class="n">h_floquet_size</span> <span class="o">=</span>
    <span class="n">openmmfC</span><span class="o">.</span><span class="n">multimodefloquetmatrix_c_python_</span><span class="p">(</span><span class="n">id_p</span><span class="p">,</span><span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">nm</span><span class="p">),</span>
                 <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">total_frequencies</span><span class="p">),</span>
                   <span class="n">modes_num_p</span><span class="p">,</span><span class="n">fields_p</span><span class="p">,</span><span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">info</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">h_floquet_size</span>
</pre></div>
</div>
<p>The input parameter mode_num is an numpy array of integers that, as
before, defines the number of driving mode and harmonics. Also, the
input parameter info is a numpy integer. id is an instance of the class
atom_c_T and fields is an instance of the class modes_c_T . This
functions calls:</p>
<p>openmmfC.multimodefloquetmatrix_c_python_ passing all parameters by
reference.</p>
<p>The ctypes wrappers rely on the equivalence between the data types in
Fortran, C++ and Python, which should be observed rigourosly following
the Table <a class="reference external" href="#tb:datatypes">[tb:datatypes]</a></p>
<p>in Fortran, C++, Ctypes and numpy.</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><p class="last"><strong>Fortran</strong></p>
</th>
<th class="head"><strong>C++</strong></th>
<th class="head"><strong>ctypes</strong></th>
<th class="head"><strong>numpy</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>integer</td>
<td>int</td>
<td>ctypes.c_int</td>
<td>numpy.int32</td>
</tr>
<tr class="row-odd"><td>double
precision</td>
<td>double</td>
<td>ctypes.c_double</td>
<td>numpy.double</td>
</tr>
<tr class="row-even"><td>complex*16</td>
<td>std::complex
<span class="math notranslate nohighlight">\(&lt;\)</span>doub
le<span class="math notranslate nohighlight">\(&gt;\)</span></td>
<td>c_dcmplx =
ctypes.c_double
<a href="#id13"><span class="problematic" id="id14">*</span></a>2</td>
<td>np.complex</td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
<div class="section" id="bugs-and-known-limitations">
<h1>Bugs and known limitations<a class="headerlink" href="#bugs-and-known-limitations" title="Permalink to this headline">¶</a></h1>
<p>If you find any bug please contact the developing team using the github
hosting link <a class="reference external" href="https://github.com/openMMF/">https://github.com/openMMF/</a></p>
</div>
<div class="section" id="acknowledgements">
<h1>Acknowledgements<a class="headerlink" href="#acknowledgements" title="Permalink to this headline">¶</a></h1>
<p>This work has been supported by the EPSRC grants EP/I010394/1 and
EP/M013294/1.</p>
</div>
<div class="section" id="modules">
<h1>MODULES<a class="headerlink" href="#modules" title="Permalink to this headline">¶</a></h1>
<p>In this section we provide the header of each one of the subroutines of
the library, including the argument declaration, to help the user to
identify the type of variable expected by each function.</p>
<div class="section" id="physical-constants">
<h2>Physical Constants<a class="headerlink" href="#physical-constants" title="Permalink to this headline">¶</a></h2>
<p>The module physical_constants defines the default values of commonly
used parameters defining the Hamiltonian of atomic systems. The user can
modify these values accessing the file in src/Modules.f90 .</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MODULE</span> <span class="n">physical_constants</span>
  <span class="n">IMPLICIT</span> <span class="n">NONE</span>
  <span class="n">DOUBLE</span> <span class="n">PRECISION</span><span class="p">,</span> <span class="n">PARAMETER</span> <span class="p">::</span> <span class="n">pi</span>           <span class="o">=</span> <span class="mf">4.0</span><span class="o">*</span><span class="n">ATAN</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
  <span class="n">DOUBLE</span> <span class="n">PRECISION</span><span class="p">,</span> <span class="n">PARAMETER</span> <span class="p">::</span> <span class="n">e</span>            <span class="o">=</span> <span class="mf">1.602176462</span><span class="n">D</span><span class="o">-</span><span class="mi">19</span>
  <span class="n">DOUBLE</span> <span class="n">PRECISION</span><span class="p">,</span> <span class="n">PARAMETER</span> <span class="p">::</span> <span class="n">h_P</span>          <span class="o">=</span> <span class="mf">6.62606957</span><span class="n">D</span><span class="o">-</span><span class="mi">34</span>
  <span class="n">DOUBLE</span> <span class="n">PRECISION</span><span class="p">,</span> <span class="n">PARAMETER</span> <span class="p">::</span> <span class="n">hbar</span>         <span class="o">=</span> <span class="n">h_P</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="mf">4.0</span><span class="o">*</span><span class="n">ATAN</span><span class="p">(</span><span class="mf">1.0</span><span class="p">))</span>
  <span class="n">DOUBLE</span> <span class="n">PRECISION</span><span class="p">,</span> <span class="n">PARAMETER</span> <span class="p">::</span> <span class="n">mu_B</span>         <span class="o">=</span> <span class="mf">9.27400968</span><span class="n">D</span><span class="o">-</span><span class="mi">24</span>
  <span class="n">DOUBLE</span> <span class="n">PRECISION</span><span class="p">,</span> <span class="n">PARAMETER</span> <span class="p">::</span> <span class="n">k_B</span>          <span class="o">=</span> <span class="mf">1.3806488</span><span class="n">D</span><span class="o">-</span><span class="mi">23</span>
  <span class="n">DOUBLE</span> <span class="n">PRECISION</span><span class="p">,</span> <span class="n">PARAMETER</span> <span class="p">::</span> <span class="n">mu_cero</span>      <span class="o">=</span> <span class="mf">12.566370614</span><span class="n">D</span><span class="o">-</span><span class="mi">7</span>
  <span class="n">DOUBLE</span> <span class="n">PRECISION</span><span class="p">,</span> <span class="n">PARAMETER</span> <span class="p">::</span> <span class="n">epsilon_cero</span> <span class="o">=</span> <span class="mf">8.854187817</span><span class="n">D</span><span class="o">-</span><span class="mi">12</span>
  <span class="n">DOUBLE</span> <span class="n">PRECISION</span><span class="p">,</span> <span class="n">PARAMETER</span> <span class="p">::</span> <span class="n">amu</span>          <span class="o">=</span> <span class="mf">1.660538921</span><span class="n">D</span><span class="o">-</span><span class="mi">27</span>
  <span class="n">DOUBLE</span> <span class="n">PRECISION</span><span class="p">,</span> <span class="n">PARAMETER</span> <span class="p">::</span> <span class="n">g_t</span>          <span class="o">=</span> <span class="mf">9.8</span><span class="n">D0</span>
  <span class="n">DOUBLE</span> <span class="n">PRECISION</span><span class="p">,</span> <span class="n">PARAMETER</span> <span class="p">::</span> <span class="n">SB_ct</span>        <span class="o">=</span> <span class="mf">5.6704</span><span class="n">D</span><span class="o">-</span><span class="mi">8</span>
  <span class="n">COMPLEX</span><span class="o">*</span><span class="mi">16</span><span class="p">,</span>       <span class="n">PARAMETER</span> <span class="p">::</span> <span class="n">J_IMAG</span>       <span class="o">=</span> <span class="n">DCMPLX</span><span class="p">(</span><span class="mf">0.0</span><span class="n">D0</span><span class="p">,</span><span class="mf">1.0</span><span class="n">D0</span><span class="p">)</span>
  <span class="n">DOUBLE</span> <span class="n">PRECISION</span><span class="p">,</span> <span class="n">PARAMETER</span> <span class="p">::</span> <span class="n">speedoflight</span> <span class="o">=</span> <span class="mf">299792458.0</span><span class="n">D0</span>
  <span class="n">DOUBLE</span> <span class="n">PRECISION</span>            <span class="p">::</span> <span class="n">TOTAL_TIME</span>
<span class="n">END</span> <span class="n">MODULE</span> <span class="n">physical_constants</span>
</pre></div>
</div>
</div>
<div class="section" id="arrays">
<h2>Arrays<a class="headerlink" href="#arrays" title="Permalink to this headline">¶</a></h2>
<p>The module ARRAYS provides global definitions of matrices. When using
the module, the user cannot define variables using any of the names
declared in this module.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MODULE</span> <span class="n">ARRAYS</span>
  <span class="n">DOUBLE</span> <span class="n">PRECISION</span><span class="p">,</span> <span class="n">DIMENSION</span><span class="p">(:,:),</span> <span class="n">ALLOCATABLE</span> <span class="p">::</span> <span class="n">Identity</span><span class="p">,</span><span class="n">j_x</span><span class="p">,</span><span class="n">j_y</span><span class="p">,</span><span class="n">j_z</span><span class="p">,</span><span class="n">I_x</span><span class="p">,</span><span class="n">I_y</span><span class="p">,</span><span class="n">I_z</span>
  <span class="n">COMPLEX</span><span class="o">*</span><span class="mi">16</span><span class="p">,</span>       <span class="n">DIMENSION</span><span class="p">(:,:),</span> <span class="n">ALLOCATABLE</span> <span class="p">::</span> <span class="n">H_IJ</span><span class="p">,</span><span class="n">HAMILTONIAN</span>
  <span class="n">COMPLEX</span><span class="o">*</span><span class="mi">16</span><span class="p">,</span>       <span class="n">DIMENSION</span><span class="p">(:,:),</span> <span class="n">ALLOCATABLE</span> <span class="p">::</span> <span class="n">H_FLOQUET</span><span class="p">,</span><span class="n">H_FLOQUET_COPY</span>
  <span class="n">COMPLEX</span><span class="o">*</span><span class="mi">16</span><span class="p">,</span>       <span class="n">DIMENSION</span><span class="p">(:,:),</span> <span class="n">ALLOCATABLE</span> <span class="p">::</span> <span class="n">U_ZEEMAN</span>
<span class="n">END</span> <span class="n">MODULE</span> <span class="n">ARRAYS</span>
</pre></div>
</div>
<p>To deallocate these arrays, the user can invoke the call:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CALL</span> <span class="n">DEALLOCATEALL</span><span class="p">(</span><span class="n">ID</span><span class="p">)</span>
</pre></div>
</div>
<p>where the variable TYPE(ATOM) ID defines the type of problem.</p>
</div>
<div class="section" id="atomic-properties">
<h2>Atomic properties<a class="headerlink" href="#atomic-properties" title="Permalink to this headline">¶</a></h2>
<p>The ATOMIC_PROPERTIES module defines the default physical parameters of
common alkali atomic species used in the context of ultracold atomic
physics.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>MODULE ATOMIC_PROPERTIES
  USE physical_constants
  IMPLICIT NONE
  DOUBLE PRECISION :: L=0.0D0,  S = 0.5D0
  DOUBLE PRECISION :: mass_at = 87*amu
  DOUBLE PRECISION :: I,g_I,g_J
  DOUBLE PRECISION :: J,F,gf,mf
  DOUBLE PRECISION :: gF_2,gF_1,G_F
  DOUBLE PRECISION :: A,a_s,alpha_E
  INTEGER          :: Fup,Fdown,Ftotal
  INTEGER          :: Total_states_LSI
  CHARACTER(LEN=7) :: ID_name

  !87Rb
  DOUBLE PRECISION :: I_87Rb   =  1.5D0
  DOUBLE PRECISION :: J_87Rb   =  0.5D0
  DOUBLE PRECISION :: gJ_87Rb  =  2.0D0
  DOUBLE PRECISION :: gI_87Rb  = -0.000995D0
  DOUBLE PRECISION :: A_87Rb   =  2*pi*hbar*3.417341D9
  DOUBLE PRECISION :: a_s_87Rb = 5.77D-9
  DOUBLE PRECISION :: alpha_E_87Rb = 2*pi*hbar*0.0794*1D-4
  INTEGER          :: Fup_87Rb     =  2
  INTEGER          :: Fdown_87Rb   =  1
  CHARACTER(LEN=7) :: ID_name_87Rb = &quot;87Rb&quot;

  !6Li
  DOUBLE PRECISION :: I_6Li   =  1.0D0
  DOUBLE PRECISION :: J_6Li   =  0.5D0
  DOUBLE PRECISION :: gJ_6Li  =  2.0D0
  DOUBLE PRECISION :: gI_6Li  = -0.000995D0
  DOUBLE PRECISION :: A_6Li   =  2*pi*hbar*152.137D6
  DOUBLE PRECISION :: a_s_6Li = 5.77D-9
  DOUBLE PRECISION :: alpha_E_6Li = 2*pi*hbar*0.0794*1D-4
  INTEGER          :: Fup_6Li     =  1
  INTEGER          :: Fdown_6Li   =  1
  CHARACTER(LEN=7) :: ID_name_6Li = &quot;6Li&quot;

  !qubit
  DOUBLE PRECISION :: I_qubit   =  0.0D0
  DOUBLE PRECISION :: J_qubit   =  0.0D0
  DOUBLE PRECISION :: gJ_qubit  =  1.0D0
  DOUBLE PRECISION :: gI_qubit  =  0.0D0
  DOUBLE PRECISION :: A_qubit   =  1.0D0
  DOUBLE PRECISION :: a_s_qubit =  0.0D0
  DOUBLE PRECISION :: alpha_E_qubit = 0.0D0
  INTEGER          :: Fup_qubit     =  1
  INTEGER          :: Fdown_qubit   =  1
  CHARACTER(LEN=7) :: ID_name_qubit = &quot;qubit&quot;


  !spin
  DOUBLE PRECISION :: I_spin   =  0.0D0
  DOUBLE PRECISION :: J_spin   =  0.0D0
  DOUBLE PRECISION :: gJ_spin  =  1.0D0
  DOUBLE PRECISION :: gI_spin  =  0.0D0
  DOUBLE PRECISION :: A_spin   =  1.0D0
  DOUBLE PRECISION :: a_s_spin =  0.0D0
  DOUBLE PRECISION :: alpha_E_spin = 0.0D0
  INTEGER          :: Fup_spin     =  1
  INTEGER          :: Fdown_spin   =  1
  CHARACTER(LEN=7) :: ID_name_spin = &quot;spin&quot;


  !lattice
  CHARACTER        :: PERIODIC
  CHARACTER(LEN=7) :: ID_name_lattice = &quot;lattice&quot;

END MODULE ATOMIC_PROPERTIES
</pre></div>
</div>
</div>
<div class="section" id="mkl">
<h2>MKL<a class="headerlink" href="#mkl" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>MODULE FEAST
  integer     fpm(128)
  real*8      Emin,Emax
  real*8      epsout
  integer     loop
  integer     M0 ! initial guess
  integer     M1 ! total number of eigenvalues found
  integer     info_FEAST
  real*8,     DIMENSION(:),   ALLOCATABLE :: E, RES ! vector of eigenvalues
  complex*16, DIMENSION(:,:), ALLOCATABLE :: X      ! matrix with eigenvectore
END MODULE FEAST
</pre></div>
</div>
</div>
</div>
<div class="section" id="derived-types-src-modes-f90">
<span id="sec-derivedtypes"></span><h1>DERIVED TYPES (src/modes.f90)<a class="headerlink" href="#derived-types-src-modes-f90" title="Permalink to this headline">¶</a></h1>
<p>The derived type defined</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MODULE</span> <span class="n">TYPES</span>

  <span class="n">TYPE</span> <span class="p">::</span> <span class="n">MODE</span>
     <span class="n">DOUBLE</span> <span class="n">PRECISION</span> <span class="p">::</span> <span class="n">OMEGA</span>
     <span class="n">COMPLEX</span><span class="o">*</span><span class="mi">16</span>       <span class="p">::</span> <span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span>
     <span class="n">DOUBLE</span> <span class="n">PRECISION</span> <span class="p">::</span> <span class="n">phi_x</span><span class="p">,</span><span class="n">phi_y</span><span class="p">,</span><span class="n">phi_z</span>
     <span class="n">INTEGER</span>          <span class="p">::</span> <span class="n">N_Floquet</span>
     <span class="n">COMPLEX</span><span class="o">*</span><span class="mi">16</span><span class="p">,</span> <span class="n">DIMENSION</span><span class="p">(:,:),</span> <span class="n">ALLOCATABLE</span> <span class="p">::</span> <span class="n">V</span>
     <span class="n">COMPLEX</span><span class="o">*</span><span class="mi">16</span><span class="p">,</span> <span class="n">DIMENSION</span><span class="p">(:),</span>   <span class="n">ALLOCATABLE</span> <span class="p">::</span> <span class="n">VALUES</span>
     <span class="n">INTEGER</span><span class="p">,</span>    <span class="n">DIMENSION</span><span class="p">(:),</span>   <span class="n">ALLOCATABLE</span> <span class="p">::</span> <span class="n">ROW</span><span class="p">,</span><span class="n">COLUMN</span>
  <span class="n">END</span> <span class="n">TYPE</span> <span class="n">MODE</span>

  <span class="n">TYPE</span> <span class="p">::</span> <span class="n">ATOM</span>
     <span class="n">INTEGER</span>          <span class="p">::</span> <span class="n">id_system</span>
     <span class="n">INTEGER</span>          <span class="p">::</span> <span class="n">D_BARE</span>
     <span class="n">DOUBLE</span> <span class="n">PRECISION</span><span class="p">,</span> <span class="n">DIMENSION</span><span class="p">(:),</span> <span class="n">ALLOCATABLE</span> <span class="p">::</span> <span class="n">E_BARE</span>
  <span class="n">END</span> <span class="n">TYPE</span> <span class="n">ATOM</span>

  <span class="n">TYPE</span> <span class="p">::</span> <span class="n">HARMONIC_FACTORS</span>
     <span class="n">COMPLEX</span><span class="o">*</span><span class="mi">16</span><span class="p">,</span><span class="n">DIMENSION</span><span class="p">(:,:),</span> <span class="n">ALLOCATABLE</span> <span class="p">::</span> <span class="n">U</span><span class="p">,</span><span class="n">U_r</span><span class="p">,</span><span class="n">U_AVG</span>
     <span class="n">INTEGER</span><span class="p">,</span>   <span class="n">DIMENSION</span><span class="p">(:),</span>   <span class="n">ALLOCATABLE</span> <span class="p">::</span> <span class="n">n</span>
  <span class="n">END</span> <span class="nb">type</span> <span class="n">HARMONIC_FACTORS</span>

<span class="n">END</span> <span class="n">MODULE</span> <span class="n">TYPES</span>
</pre></div>
</div>
</div>
<div class="section" id="computational-subroutines">
<h1>COMPUTATIONAL SUBROUTINES<a class="headerlink" href="#computational-subroutines" title="Permalink to this headline">¶</a></h1>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>MODULE FLOQUETINITINTERFACE
  INTERFACE FLOQUETINIT
     MODULE PROCEDURE FLOQUETINIT_QUBIT, FLOQUETINIT_SPIN,FLOQUETINIT_ALKALI
  END INTERFACE FLOQUETINIT
contains
  SUBROUTINE FLOQUETINIT_QUBIT(ID,atomicspecie,INFO)
    ! ATOMICSPECIE: 87Rb,6Li,Cs,41K,qubit,lattice, SPIN
    ! MANIFOLD : &quot;U&quot; UPPER HYPERFINE MANIFOLD, &quot;L&quot; LOWER HYPERFIND MANIFOLD, &quot;B&quot; BOTH
    ! JTOTAL   :  IF ATOMICSPECIE .EQ. SPIN THEN JTOTAL IS THE TOTAL ANGULAR MOMENTUM OF THE SPIN
    !             IF ATOMICSPECIE .EQ. LATTICE, THEN JTOTAL IS THE NUMBER OF SITES
    ! calculate the dimenson of the Hilbert space
    ! initialize all the matrices required for a full Floquet calcuations
    ! Calculate the nuclear, electron and total angular momentum operators

  TYPE(ATOM),        INTENT(INOUT) :: ID
  CHARACTER (LEN=*), INTENT(IN)    :: ATOMICSPECIE
  INTEGER,           INTENT(INOUT) :: INFO

...


SUBROUTINE FLOQUETINIT_SPIN(ID,atomicspecie,jtotal,info)
  ! ATOMICSPECIE: 87Rb,6Li,Cs,41K,qubit,lattice, SPIN
  ! MANIFOLD : &quot;U&quot; UPPER HYPERFINE MANIFOLD, &quot;L&quot; LOWER HYPERFIND MANIFOLD, &quot;B&quot; BOTH
  ! JTOTAL   :  IF ATOMICSPECIE .EQ. SPIN THEN JTOTAL IS THE TOTAL ANGULAR MOMENTUM OF THE SPIN
  !             IF ATOMICSPECIE .EQ. LATTICE, THEN JTOTAL IS THE NUMBER OF SITES


  ! calculate the dimenson of the Hilbert space
  ! initialize all the matrices required for a full Floquet calcuations
  ! Calculate the nuclear, electron and total angular momentum operators

  IMPLICIT NONE
  TYPE(ATOM),        INTENT(INOUT) :: ID
  CHARACTER (LEN=*), INTENT(IN)    :: ATOMICSPECIE
  DOUBLE PRECISION,  intent(in)    :: jtotal
  INTEGER,           INTENT(INOUT) :: INFO

...

SUBROUTINE FLOQUETINIT_ALKALI(ID,atomicspecie,manifold,info)
  ! ATOMICSPECIE: 87Rb,6Li,Cs,41K,qubit,lattice, SPIN
  ! MANIFOLD : &quot;U&quot; UPPER HYPERFINE MANIFOLD, &quot;L&quot; LOWER HYPERFIND MANIFOLD, &quot;B&quot; BOTH
  ! JTOTAL   :  IF ATOMICSPECIE .EQ. SPIN THEN JTOTAL IS THE TOTAL ANGULAR MOMENTUM OF THE SPIN
  !             IF ATOMICSPECIE .EQ. LATTICE, THEN JTOTAL IS THE NUMBER OF SITES


  ! calculate the dimenson of the Hilbert space
  ! initialize all the matrices required for a full Floquet calcuations
  ! Calculate the nuclear, electron and total angular momentum operators

  TYPE(ATOM),        INTENT(INOUT) :: ID
  CHARACTER (LEN=*), INTENT(IN)    :: ATOMICSPECIE
  CHARACTER (LEN=1), INTENT(IN)    :: MANIFOLD
  INTEGER,           INTENT(INOUT) :: INFO

...

END MODULE FLOQUETINITINTERFACE
</pre></div>
</div>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SUBROUTINE SETHAMILTONIANCOMPONENTS(ID,NM,NF,MODES_NUM,FIELD,INFO)
  ! ID  tYPE OF ATOM
  ! MODES_NUM, VECTOR. THE SIZE OF THE VECTOR TELL US THE NUMBER OF
  !           FREQUENCIES, AND THE VALUE OF EACH COMPONENT INDICATES
  !           THE NUMBER OF  HARMONICS OF EACH FREQUENCI
  ! FIELDS : IN AND OUTPUT THE MATRICES
  ! INFO

  USE ARRAYS
  USE ATOMIC_PROPERTIES
  USE TYPES
  USE SUBINTERFACE_LAPACK ! write_matrix interface

  IMPLICIT NONE
  INTEGER,                   INTENT(IN)    :: NM,NF
  TYPE(ATOM),                INTENT(IN)    :: ID
  INTEGER,    DIMENSION(NM), INTENT(IN)    :: MODES_NUM
  TYPE(MODE), DIMENSION(NF), INTENT(INOUT) :: FIELD
  INTEGER,                   INTENT(INOUT) :: INFO
</pre></div>
</div>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SUBROUTINE F_representation(Fx,Fy,Fz,Ftotal)

  USE FUNCIONES

  IMPLICIT NONE
  DOUBLE PRECISION, DIMENSION(:,:), INTENT(OUT):: Fx,Fy,Fz
  DOUBLE PRECISION, INTENT(IN) :: Ftotal
  !INTEGER, INTENT(IN) :: Ftotal_

  !DOUBLE PRECISION
  INTEGER k,p,N_k
  double precision k_!,Ftotal

  Fx = 0.0
  Fy = 0.0
  Fz = 0.0
</pre></div>
</div>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SUBROUTINE</span> <span class="n">I_and_J_representations</span><span class="p">(</span><span class="n">j_x</span><span class="p">,</span><span class="n">j_y</span><span class="p">,</span><span class="n">j_z</span><span class="p">,</span><span class="n">I_x</span><span class="p">,</span><span class="n">I_y</span><span class="p">,</span><span class="n">I_z</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">I</span><span class="p">)</span>

  <span class="n">USE</span> <span class="n">FUNCIONES</span>

  <span class="n">IMPLICIT</span>  <span class="n">NONE</span>
  <span class="n">DOUBLE</span> <span class="n">PRECISION</span><span class="p">,</span> <span class="n">DIMENSION</span><span class="p">(:,:),</span><span class="n">INTENT</span><span class="p">(</span><span class="n">INOUT</span><span class="p">)</span> <span class="p">::</span> <span class="n">j_x</span><span class="p">,</span><span class="n">j_y</span><span class="p">,</span><span class="n">j_z</span><span class="p">,</span><span class="n">I_x</span><span class="p">,</span><span class="n">I_y</span><span class="p">,</span><span class="n">I_z</span>
  <span class="n">DOUBLE</span> <span class="n">PRECISION</span><span class="p">,</span> <span class="n">INTENT</span><span class="p">(</span><span class="n">IN</span><span class="p">)</span> <span class="p">::</span> <span class="n">L</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">I</span>
</pre></div>
</div>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SUBROUTINE MULTIMODETIMEEVOLUTINOPERATOR(D,NM,MODES_NUM,U_F_MODES,E_MULTIFLOQUET,
                                                D_BARE,FIELD,T1,T2,U,INFO)

  ! TIME EVOLUTION OPERATOR OF A MULTIMODE DRESSED SYSTEM.
  ! THE EVOLUTION OPERATOR IS WRITEN IN THE BASIS USED TO EXPRESS THE
  ! MULTIMODE FLOQUET HAMILTONIAN
  ! U : MATRIX OF AMPLITUED OF PROBABILITIES FOR TRANSITIONS BETWEEN T1 TO T2
!!$  D              (IN)   : DIMENSION OF THE EXTENDED HILBERT SPACE
!!$                          (SIZE OF THE MULTIMODE FLOQUET MATRIX)
!!$  NM             (IN)   : NUMBER OF MODES
!!$  MODES_NUM      (IN)   : VECTOR (NM) INDICATING THE NUMBER OF HARMONICS OF EACH MODE
!!$  U_F_MODES      (IN)   : TRANSFORMATION, DIMENSOON (D,D)
!!$  E_MULTIFLOQUET (IN)   : MULTIMODE FLOQUET SPECTRUM
!!$  D_BARE         (IN)   : DIMENSION OF THE BARE HILBERT SPACE
!!$  FIELD          (IN)   : STRUCTURE DESCRIBING THE COUPLINGS
!!$  T1             (IN)   : INITIAL TIME
!!$  T2             (IN)   : FINAL TIME
!!$  U              (OUT)  : TRANFORMATION BETWEEN THE EXTENDED BARE BASIS AND
!!$                          THE FLOQUET STATES, DIMENSION (D_BARE,D)
!!$  INFO           (INOUT): (POSSIBLE) ERROR FLAG

  USE TYPES
  USE SUBINTERFACE_LAPACK


  IMPLICIT NONE
  INTEGER,                                    INTENT(IN)    :: D,D_BARE,NM
  INTEGER,                                    INTENT(INOUT) :: INFO
  INTEGER,          DIMENSION(NM),            INTENT(IN)    :: MODES_NUM
  TYPE(MODE),       DIMENSION(NM),            INTENT(IN)    :: FIELD
  DOUBLE PRECISION,                           INTENT(IN)    :: T1,T2
  DOUBLE PRECISION, DIMENSION(D),             INTENT(IN)    :: E_MULTIFLOQUET
  COMPLEX*16,       DIMENSION(D,D),           INTENT(IN)    :: U_F_MODES
  COMPLEX*16,       DIMENSION(D_BARE,D_BARE), INTENT(OUT)   :: U
</pre></div>
</div>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SUBROUTINE MULTIMODEFLOQUETMATRIX(ATOM_,NM,NF,MODES_NUM,FIELD,INFO)
  !ID,size(modes_num,1),total_frequencies,MODES_NUM,FIELDS,INFO
  !  USE FLOQUET
  !ATOM_ type atom, -&gt; dimension of the bare Hilbert space
  !NM -&gt; number of modes
  !NF -&gt; Number of Fields
  !MODES_NUM -&gt; number of harmonics of each mode
  !FIELD -&gt; Field couplings
  !INFO


  USE ARRAYS
  USE ATOMIC_PROPERTIES
  USE TYPES
  USE SUBINTERFACE_LAPACK

  IMPLICIT NONE
  INTEGER,                  INTENT(IN)    :: NM,NF
  INTEGER,                  INTENT(INOUT) :: INFO
  INTEGER,   DIMENSION(NM), INTENT(IN)    :: MODES_NUM
  TYPE(MODE),DIMENSION(NF), INTENT(IN)    :: FIELD
  TYPE(ATOM),               INTENT(IN)    :: ATOM_
</pre></div>
</div>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SUBROUTINE MULTIMODEFLOQUETMATRIX_SP(ATOM__,NM,NF,MODES_NUM,FIELDS,VALUES_,ROW_INDEX_,COLUMN_,INFO)

!ATOM_      (IN)    : type of quantum system
!NM         (IN)    : number of modes
!NF         (IN)    : number of driving fields
!MODES_NUM  (IN)    : vector indicating the number of harmonics of each driving field (mode)
!FIELDS     (IN)    : Fields
!VALUES_    (OUT)   : Hamiltonian values
!ROW_INDEX_ (OUT)   : vector indicating the row position of values
!COLUMN_    (OUT)   : vector indicating the column position of the values
!INFO       (INOUT) : error flag. INFO=0 means there is no error

  USE TYPES         !(modes.f90)
  USE MERGINGARRAYS !(utils.f90)

  IMPLICIT NONE
  INTEGER                  ,            INTENT(IN)    :: NM,NF
  TYPE(MODE), DIMENSION(NF),            INTENT(INOUT) :: FIELDS
  TYPE(ATOM),                           INTENT(IN)    :: ATOM__
  INTEGER,    DIMENSION(NM),            INTENT(IN)    :: MODES_NUM
  INTEGER,                              INTENT(INOUT) :: INFO
  COMPLEX*16, DIMENSION(:), ALLOCATABLE,INTENT(OUT)   :: VALUES_
  INTEGER,    DIMENSION(:), ALLOCATABLE,INTENT(OUT)   :: COLUMN_
  INTEGER,    DIMENSION(:), ALLOCATABLE,INTENT(OUT)   :: ROW_INDEX_
</pre></div>
</div>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SUBROUTINE MULTIMODEFLOQUETTRANSFORMATION(D,NM,MODES_NUM,U_F_MODES,E_MULTIFLOQUET,
                                                                D_BARE,FIELD,T1,U,INFO)

  ! TIME-DEPENDENT TRANSFORMATION BETWEEN THE EXTENDED BARE BASIS AND THE FLOQUET STATES
  ! U(T1) = sum_ U^n exp(i n omega T1)
  !
!!$  D              (IN)   : DIMENSION OF THE EXTENDED HILBERT SPACE (SIZE OF THE MULTIMODE FLOQUET MATRIX)
!!$  NM             (IN)   : NUMBER OF MODES
!!$  MODES_NUM      (IN)   : VECTOR (NM) INDICATING THE NUMBER OF HARMONICS OF EACH MODE
!!$  U_F_MODES      (IN)   : TRANSFORMATION, DIMENSOON (D,D)
!!$  E_MULTIFLOQUET (IN)   : MULTIMODE FLOQUET SPECTRUM
!!$  D_BARE         (IN)   : DIMENSION OF THE BARE HILBERT SPACE
!!$  FIELD          (IN)   : STRUCTURE DESCRIBING THE COUPLINGS
!!$  T1             (IN)   : TIME. THE BARE 2 DRESSED TRANSFORMATINO IS TIME DEPENDENT
!!$  U              (OUT)  : TRANFORMATION BETWEEN THE EXTENDED BARE BASIS AND THE FLOQUET STATES,
!!$                          DIMENSION (D_BARE,D)
!!$  INFO           (INOUT): (POSSIBLE) ERROR FLAG

  USE TYPES

  IMPLICIT NONE
  INTEGER,                                    INTENT(IN)    :: D,D_BARE,NM
  INTEGER,                                    INTENT(INOUT) :: INFO
  INTEGER,          DIMENSION(NM),            INTENT(IN)    :: MODES_NUM
  TYPE(MODE),       DIMENSION(NM),            INTENT(IN)    :: FIELD
  DOUBLE PRECISION,                           INTENT(IN)    :: T1
  DOUBLE PRECISION, DIMENSION(D),             INTENT(IN)    :: E_MULTIFLOQUET
  COMPLEX*16,       DIMENSION(D,D),           INTENT(IN)    :: U_F_MODES
  COMPLEX*16,       DIMENSION(D_BARE,D),      INTENT(OUT)   :: U
</pre></div>
</div>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SUBROUTINE MULTIMODEMICROMOTION(ID,D,NM,MODES_NUM,U_F_MODES,E_MULTIFLOQUET,D_BARE,FIELD,T1,U,INFO)

  ! TIME-DEPENDENT TRANSFORMATION BETWEEN THE EXTENDED BARE BASIS AND THE FLOQUET STATES
  ! U(T1) = sum_ U^n exp(i n omega T1)
  !
!!$  D              (IN)   : DIMENSION OF THE EXTENDED HILBERT SPACE (SIZE OF THE MULTIMODE FLOQUET MATRIX)
!!$  NM             (IN)   : NUMBER OF MODES
!!$  MODES_NUM      (IN)   : VECTOR (NM) INDICATING THE NUMBER OF HARMONICS OF EACH MODE
!!$  U_F_MODES      (IN)   : TRANSFORMATION, DIMENSOON (D,D)
!!$  E_MULTIFLOQUET (IN)   : MULTIMODE FLOQUET SPECTRUM
!!$  D_BARE         (IN)   : DIMENSION OF THE BARE HILBERT SPACE
!!$  FIELD          (IN)   : STRUCTURE DESCRIBING THE COUPLINGS
!!$  T1             (IN)   : TIME. THE BARE 2 DRESSED TRANSFORMATINO IS TIME DEPENDENT
!!$  U              (OUT)  : TRANFORMATION BETWEEN THE EXTENDED BARE BASIS AND THE FLOQUET STATES, DIMENSION (D_BARE,D)
!!$  INFO           (INOUT): (POSSIBLE) ERROR FLAG

  !USE TYPES_C
  USE TYPES
  !USE MODES_4F
  USE SUBINTERFACE_LAPACK
  USE ATOMIC_PROPERTIES

  IMPLICIT NONE
  TYPE(ATOM),                INTENT(IN)    :: ID
  INTEGER,                                    INTENT(IN)    :: D,D_BARE,NM
  INTEGER,                                    INTENT(INOUT) :: INFO
  INTEGER,          DIMENSION(NM),            INTENT(IN)    :: MODES_NUM
  TYPE(MODE),       DIMENSION(NM),            INTENT(IN)    :: FIELD
  DOUBLE PRECISION,                           INTENT(IN)    :: T1
  DOUBLE PRECISION, DIMENSION(D),             INTENT(IN)    :: E_MULTIFLOQUET
  COMPLEX*16,       DIMENSION(D,D),           INTENT(IN)    :: U_F_MODES
  COMPLEX*16,       DIMENSION(D_BARE,D_BARE), INTENT(OUT)   :: U
</pre></div>
</div>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SUBROUTINE MICROMOTIONFOURIERDRESSEDBASIS(ID,DRESSINGFIELDS_INDICES,MODES_NUM,FIELDS,
                                                                      U_FD,E_DRESSED,INFO)
! ID        (in)    :: TYPE(ATOM) system ID
! DRESSINGFIELDS_INDICES (in) :: integer array indicating the indices of the dressing modes
! MODES_NUM (in)    :: integer array indicating the number of harmonics of all driving modes
! FIELDS    (in)    :: Array of TYPE(MODE) of dimension
! U_FD      (out)   :: complex*16 matrix fourier decomposition of the micromotion operator of the dressed basis
! E_DRESSED (out)   :: dressed energies
! INFO      (inout) :: error flag
  USE TYPES

  TYPE(ATOM),                     INTENT(IN)  :: ID
  INTEGER,    DIMENSION(:),       INTENT(IN)  :: DRESSINGFIELDS_INDICES
  INTEGER,    DIMENSION(:),       INTENT(IN)  :: MODES_NUM
  TYPE(MODE), DIMENSION(:),       INTENT(IN)  :: FIELDS
  COMPLEX*16, DIMENSION(:,:),     ALLOCATABLE, INTENT(OUT) :: U_FD
  DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE, INTENT(OUT) :: E_DRESSED
</pre></div>
</div>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SUBROUTINE MICROMOTIONDRESSEDBASIS(ID,MODES_NUM,DRESSINGFIELDS_INDICES,FIELDS,
                                                       U_F_MODES,E_MULTIFLOQUET,T1,U,INFO)

! ID (in)        :: TYPE(ATOM) system ID
! MODES_NUM (in) :: integer array indicating the number of harmonics of each driving mode
! DRESSINFIELDS_INDICES :: integer array indicating the indices of the dressing modes
! FIELDS         :: Array of TYPE(MODES) with NM components (all driving fields)
! U_F_MODES      :: complex*16 matrix of dimension DxD. Fourier decomposition of the micromotion operator of the dressed basis
! E_MULTIFLOQUET :: dressed energies
! T1             :: double precision, time
! U              :: complex*16 matrix of dimension D_BARE x D_BARE. micromotion operator at time T1
! INFO           :: error flag


  USE TYPES
  IMPLICIT NONE
  TYPE(ATOM),                       INTENT(IN)    :: ID
  INTEGER,          DIMENSION(:),   INTENT(IN)    :: MODES_NUM
  INTEGER,          DIMENSION(:),   INTENT(IN)    :: DRESSINGFIELDS_INDICES
  COMPLEX*16,       DIMENSION(:,:), INTENT(IN)    :: U_F_MODES
  DOUBLE PRECISION, DIMENSION(:),   INTENT(IN)    :: E_MULTIFLOQUET
  TYPE(MODE),       DIMENSION(:),   INTENT(IN)    :: FIELDS
  DOUBLE PRECISION ,                INTENT(IN)    :: T1
  COMPLEX*16,       DIMENSION(:,:), INTENT(OUT)   :: U
  INTEGER,                          INTENT(INOUT) :: INFO
</pre></div>
</div>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SUBROUTINE MULTIMODETRANSITIONAVG(D,NM,FIELD,MODES_NUM,U_F_MODES,
                                              E_MULTIFLOQUET,D_BARE,U,INFO)
!!$   AVERAGE TIME EVOLUTION OPERATOR OF A MULTIMODE DRESSED SYSTEM.
!!$   THE AVERAGE EVOLUTION OPERATOR IS WRITEN IN THE BASIS USED TO EXPRESS THE
!!$   MULTIMODE FLOQUET HAMILTONIAN
!!$   U : MATRIX OF AVERAGE TRANSITION PROBABILITIES
!!$
!!$  D              (IN)   : DIMENSION OF THE EXTENDED HILBERT SPACE
!!$                          (SIZE OF THE MULTIMODE FLOQUET MATRIX)
!!$  NM             (IN)   : NUMBER OF MODES
!!$  MODES_NUM      (IN)   : VECTOR (NM) INDICATING THE NUMBER OF HARMONICS OF EACH MODE
!!$  U_F_MODES      (IN)   : TRANSFORMATION, DIMENSOON (D,D)
!!$  E_MULTIFLOQUET (IN)   : MULTIMODE FLOQUET SPECTRUM
!!$  D_BARE         (IN)   : DIMENSION OF THE BARE HILBERT SPACE
!!$  U              (OUT)  :  MATRIX OF AVERAGE TRANSITION PROBABILITIES
!!$  INFO           (INOUT): (POSSIBLE) ERROR FLAG

  USE TYPES

  IMPLICIT NONE
  TYPE(MODE),DIMENSION(NM), INTENT(IN)     :: FIELD
  INTEGER,   DIMENSION(NM), INTENT(IN)     :: MODES_NUM

  INTEGER,                                    INTENT(IN)    :: D,D_BARE,NM
  INTEGER,                                    INTENT(INOUT) :: INFO
  DOUBLE PRECISION, DIMENSION(D),             INTENT(IN)    :: E_MULTIFLOQUET
  COMPLEX*16,       DIMENSION(D,D),           INTENT(IN)    :: U_F_MODES
  DOUBLE PRECISION, DIMENSION(D_BARE,D_BARE), INTENT(OUT)   :: U
</pre></div>
</div>
<hr class="docutils" />
</div>
<div class="section" id="driver-subroutines">
<h1>DRIVER SUBROUTINES<a class="headerlink" href="#driver-subroutines" title="Permalink to this headline">¶</a></h1>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SUBROUTINE DRESSEDBASIS(D,ID,NM,MODES_NUM,FIELDS,U_FD,E_DRESSED,INFO)

!!$ THIS SUBROUTINES CALCULATES THE FOURIER COMPONENTS OF THE
!!$ TRANSFORMATION BETWEEN THE BARE BASIS TO THE DRESSED BASIS DEFINDED
!!$ BY THE FULL SET OF DRIVING FIELDS.
!!$
!!$ D                            : DIMENSION OF THE MULTIMODE EXTENDED HILBERT SPACE
!!$ ID (IN)                      : TYPE OF QUANTUM SYSTEM
!!$ NM (IN)                      : NUMBER OF MODES == NUMBER OF DRIVING FIELDS
!!$ MODES_NUM                    : VECTOR INDICATING THE NUMBER OF HARMONICS OF EACH DRESSING FIELD
!!$ FIELDS (IN)                  : AMPLITUDE, FREQUENCY AND PHASES OF ALL DRIVING FIELDS
!!$ U_FD (OUT)                   : THIS IS THE TRANSFORMATION WE ARE LOOKING FOR
!!$ E_DRESSED (OUT)              : DRESSED ENERGIES
!!$ INFO (INOUT)                 : INFO = 0 MEANS SUCESS


  USE ATOMIC_PROPERTIES
  USE TYPES
  USE SUBINTERFACE
  USE SUBINTERFACE_LAPACK
  USE FLOQUETINIT_
  USE ARRAYS

  IMPLICIT NONE
  TYPE(MODE), DIMENSION(NM),     INTENT(IN)    :: FIELDS
  TYPE(ATOM),                    INTENT(IN)    :: ID
  INTEGER,    DIMENSION(NM),     INTENT(IN)    :: MODES_NUM
  COMPLEX*16, DIMENSION(D,D),       INTENT(OUT)   :: U_FD
  DOUBLE PRECISION, DIMENSION(D), INTENT(OUT)   :: E_DRESSED
  INTEGER,                       INTENT(IN)    :: NM,D
  INTEGER,                       INTENT(INOUT) :: INFO
</pre></div>
</div>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SUBROUTINE DRESSEDBASIS_SP(D,ID,NM,MODES_NUM,FIELDS,U_FD,E_DRESSED,INFO)

!!$ THIS SUBROUTINES CALCULATES THE TRANSFORMATION BETWEEN THE BARE
!!$ BASIS TO THE DRESSED BASIS DEFINDED BY THE FULL SET OF DRIVING FIELDS.
!!$ D                            : DIMENSION OF THE MULTIMODE EXTENDED HILBERT SPACE
!!$ ID (IN)                      : TYPE OF QUATUM SYSTEM
!!$ NM (IN)                      : NUMBER OF MODES == NUMBER OF DRIVING FIELDS
!!$ MODES_NUM                    : VECTOR INDICATING THE NUMBER OF HARMONICS OF EACH DRESSING FIELD
!!$ FIELDS (IN)                  : AMPLITUDE, FREQUENCY AND PHASES OF ALL DRIVING FIELDS
!!$ U_FD (OUT)                   : THIS IS THE TRANSFORMATION WE ARE LOOKING FOR
!!$ E_DRESSED (OUT)              : DRESSED ENERGIES
!!$ INFO (INOUT)                 : INFO = 0 MEANS SUCESS


  USE ATOMIC_PROPERTIES
  USE TYPES
  USE SPARSE_INTERFACE
  USE SUBINTERFACE
  USE SUBINTERFACE_LAPACK
  USE FLOQUETINIT_
  USE ARRAYS

  IMPLICIT NONE
  TYPE(MODE), DIMENSION(NM),      INTENT(INOUT)    :: FIELDS
  TYPE(ATOM),                     INTENT(IN)    :: ID
  INTEGER,    DIMENSION(NM),      INTENT(IN)    :: MODES_NUM
  COMPLEX*16, DIMENSION(D,D),     INTENT(OUT)   :: U_FD
  DOUBLE PRECISION, DIMENSION(D), INTENT(OUT)   :: E_DRESSED
  INTEGER,                        INTENT(IN)    :: NM,D
  INTEGER,                        INTENT(INOUT) :: INFO
</pre></div>
</div>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SUBROUTINE TIMEEVOLUTIONOPERATOR(ID,D_BARE,NM,MODES_NUM,FIELD,T1,T2,U,INFO)
 ! TIME EVOLUTION OPERATOR OF A MULTIMODE DRESSED SYSTEM. THE EVOLUTION
 ! OPERATOR IS WRITEN IN THE BASIS USED TO EXPRESS THE
 ! MULTIMODE FLOQUET HAMILTONIAN
 ! U : MATRIX OF AMPLITUED OF PROBABILITIES FOR TRANSITIONS BETWEEN T1 TO T2
!!$  NM             (IN)   : NUMBER OF MODES
!!$  MODES_NUM      (IN)   : VECTOR (NM) INDICATING THE NUMBER OF HARMONICS OF EACH MODE
!!$  D_BARE         (IN)   : DIMENSION OF THE BARE HILBERT SPACE
!!$  FIELD          (IN)   : STRUCTURE DESCRIBING THE COUPLINGS
!!$  T1             (IN)   : INITIAL TIME
!!$  T2             (IN)   : FINAL TIME
!!$  U              (OUT)  : TRANFORMATION BETWEEN THE EXTENDED BARE BASIS AND
!!$                          THE FLOQUET STATES, DIMENSION (D_BARE,D)
!!$  INFO           (INOUT): (POSSIBLE) ERROR FLAG

    USE ATOMIC_PROPERTIES
    USE TYPES
    USE SUBINTERFACE
    USE SUBINTERFACE_LAPACK
    USE FLOQUETINIT_
    USE ARRAYS


    IMPLICIT NONE
    TYPE(ATOM) ,                                INTENT(IN)    :: ID
    INTEGER,                                    INTENT(IN)    :: D_BARE
    INTEGER,                                    INTENT(IN)    :: NM
    INTEGER,          DIMENSION(NM),            INTENT(IN)    :: MODES_NUM
    TYPE(MODE),       DIMENSION(NM),            INTENT(IN)    :: FIELD
    DOUBLE PRECISION,                           INTENT(IN)    :: T1
    DOUBLE PRECISION,                           INTENT(IN)    :: T2
    COMPLEX*16,       DIMENSION(D_BARE,D_BARE), INTENT(OUT)   :: U
    INTEGER,                                    INTENT(INOUT) :: INFO
</pre></div>
</div>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SUBROUTINE MICROMOTIONFOURIERDRESSEDBASIS(ID,DRESSINGFIELDS_INDICES,
                                           MODES_NUM,FIELDS, U_FD,E_DRESSED,INFO)
! THIS SUBROUTINE CALCULATES THE FOURIER COMPONENTS (U_FD) AND PHASES (E_DRESSED)
! OF THE MICROMOTION OPERATOR OF SUBSET OF DRIVING MODES
! ID        (in)    :: TYPE(ATOM) system ID
! DRESSINGFIELDS_INDICES (in) :: integer array indicating the indices of the dressing modes
! MODES_NUM (in)    :: integer array indicating the number of harmonics of all driving modes
! FIELDS    (in)    :: Array of TYPE(MODE) of dimension
! U_FD      (out)   :: complex*16 matrix fourier decomposition of the micromotion
!                      operator of the dressed basis
! E_DRESSED (out)   :: dressed energies
! INFO      (inout) :: error flag

  USE TYPES
  IMPLICIT NONE
  TYPE(ATOM),                     INTENT(IN)  :: ID
  INTEGER,    DIMENSION(:),       INTENT(IN)  :: DRESSINGFIELDS_INDICES
  INTEGER,    DIMENSION(:),       INTENT(IN)  :: MODES_NUM
  TYPE(MODE), DIMENSION(:),       INTENT(IN)  :: FIELDS
  COMPLEX*16, DIMENSION(:,:),     ALLOCATABLE, INTENT(OUT) :: U_FD
  DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE, INTENT(OUT) :: E_DRESSED
  INTEGER, INTENT(INOUT) :: INFO


END SUBROUTINE MICROMOTIONFOURIERDRESSEDBASIS
</pre></div>
</div>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SUBROUTINE MICROMOTIONDRESSEDBASIS(ID,MODES_NUM,DRESSINGFIELDS_INDICES,FIELDS,
                                                 U_F_MODES,E_MULTIFLOQUET,T1,U,INFO)
! THIS SUBROUTINE CALCULATES U: THE TIME-DEPENDENT MICROMOTION OPERATOR OF
! A SUBSET OF THE DRIVING MODES. U_F_MODES AND E_MULTIFLOQUET ARE THE ARRAYS
! CALCULATED WITH THE SUBROUTINE MICROMOTIONFOURIERDRESSEDBASIS

! ID (in)        :: TYPE(ATOM) system ID
! MODES_NUM (in) :: integer array indicating the number of harmonics of each driving mode
! DRESSINFIELDS_INDICES :: integer array indicating the indices of the dressing modes
! FIELDS         :: Array of TYPE(MODES) with NM components (all driving fields)
! U_F_MODES      :: complex*16 matrix of dimension DxD. Fourier decomposition of
!                   the micromotion operator of the dressed basis
! E_MULTIFLOQUET :: dressed energies
! T1             :: double precision, time
! U              :: complex*16 matrix of dimension D_BARE x D_BARE. micromotion operator
!                   at time T1
! INFO           :: error flag


  USE TYPES
  IMPLICIT NONE
  TYPE(ATOM),                       INTENT(IN)    :: ID
  INTEGER,          DIMENSION(:),   INTENT(IN)    :: MODES_NUM
  INTEGER,          DIMENSION(:),   INTENT(IN)    :: DRESSINGFIELDS_INDICES
  COMPLEX*16,       DIMENSION(:,:), INTENT(IN)    :: U_F_MODES
  DOUBLE PRECISION, DIMENSION(:),   INTENT(IN)    :: E_MULTIFLOQUET
  TYPE(MODE),       DIMENSION(:),   INTENT(IN)    :: FIELDS
  DOUBLE PRECISION ,                INTENT(IN)    :: T1
  COMPLEX*16,       DIMENSION(:,:), INTENT(OUT)   :: U
  INTEGER,                          INTENT(INOUT) :: INFO
</pre></div>
</div>
<div class="section" id="utility-subroutines">
<h2>Utility subroutines<a class="headerlink" href="#utility-subroutines" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SUBROUTINE PACKINGBANDMATRIX(N,A,KD,AB,INFO)

! brute force packing of a banded matrix

  IMPLICIT NONE
  INTEGER, INTENT(INOUT) :: INFO
  INTEGER, INTENT(IN)    :: N,KD
  COMPLEX*16, DIMENSION(N,N)    :: A
  COMPLEX*16, DIMENSION(KD+1,N) :: AB
</pre></div>
</div>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SUBROUTINE LAPACK_FULLEIGENVALUES(H,N,W_SPACE,INFO)
!eigenvalues/vectors of matrix ab
!H, inout, packed banded matrix
! , out,eigenvectors
!N, in,matrix dimension
!W_space, out, eigenvalues
!INFO,inout, error flag

  !H is COMPLEX*16 array, dimension (N, N)
  !  69 *&gt;          On entry, the Hermitian matrix A.  If UPLO = &#39;U&#39;, the
  !  70 *&gt;          leading N-by-N upper triangular part of A contains the
  !  71 *&gt;          upper triangular part of the matrix A.  If UPLO = &#39;L&#39;,
  !  72 *&gt;          the leading N-by-N lower triangular part of A contains
  !  73 *&gt;          the lower triangular part of the matrix A.
  !  74 *&gt;          On exit, if JOBZ = &#39;V&#39;, then if INFO = 0, A contains the
  !  75 *&gt;          orthonormal eigenvectors of the matrix A.
  !  76 *&gt;          If JOBZ = &#39;N&#39;, then on exit the lower triangle (if UPLO=&#39;L&#39;)
  !  77 *&gt;          or the upper triangle (if UPLO=&#39;U&#39;) of A, including the
  !  78 *&gt;          diagonal, is destroyed.
  !
  ! The eigenvector H(:,r) corresponds to the eigenvalue W_SPACE(r)
  !
  IMPLICIT NONE
  INTEGER,                          INTENT(IN)    :: N
  COMPLEX*16,       DIMENSION(N,N), INTENT(INOUT) :: H
  DOUBLE PRECISION, DIMENSION(N),   INTENT(INOUT) :: W_SPACE
  INTEGER,                          INTENT(OUT)   :: INFO

SUBROUTINE LAPACK_FULLEIGENVALUESBAND(AB,Z,KD,N,W,INFO)
!eigenvalues/vectors of banded matrix ab
!AB, inout, packed banded matrix
!Z, out,eigenvectors
!KD out, calcuated eigenvectors
!N, in,matrix dimension
!W, out, eigenvalues
!INFO,inout, error flag

  !H is COMPLEX*16 array, dimension (N, N)
  !  69 *&gt;          On entry, the Hermitian matrix A.  If UPLO = &#39;U&#39;, the
  !  70 *&gt;          leading N-by-N upper triangular part of A contains the
  !  71 *&gt;          upper triangular part of the matrix A.  If UPLO = &#39;L&#39;,
  !  72 *&gt;          the leading N-by-N lower triangular part of A contains
  !  73 *&gt;          the lower triangular part of the matrix A.
  !  74 *&gt;          On exit, if JOBZ = &#39;V&#39;, then if INFO = 0, A contains the
  !  75 *&gt;          orthonormal eigenvectors of the matrix A.
  !  76 *&gt;          If JOBZ = &#39;N&#39;, then on exit the lower triangle (if UPLO=&#39;L&#39;)
  !  77 *&gt;          or the upper triangle (if UPLO=&#39;U&#39;) of A, including the
  !  78 *&gt;          diagonal, is destroyed.
  !
  ! The eigenvector H(:,r) corresponds to the eigenvalue W_SPACE(r)
  !
  IMPLICIT NONE
  INTEGER,                                INTENT(IN)    :: N,KD
  COMPLEX*16,       DIMENSION(KD+1,N), INTENT(INOUT)    :: AB
  COMPLEX*16,       DIMENSION(N,N),       INTENT(INOUT) :: Z
  DOUBLE PRECISION, DIMENSION(N),         INTENT(INOUT) :: W
  INTEGER,                                INTENT(OUT)   :: INFO
</pre></div>
</div>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SUBROUTINE LAPACK_SELECTEIGENVALUES(H,N,W_SPACE,L1,L2,Z,INFO)
!selected eigenvalues/vectors of hermitian matrix
!H, inout, packed banded matrix
! , out,eigenvectors
!N, in,matrix dimension
!W_space, out, eigenvalues
!L1 ordinal lowest eigenvalue
!L2 ordinal highest eigenvlaue
!Z : eigenvectors
!INFO,inout, error flag

  !USE FLOQUET
  IMPLICIT NONE
  INTEGER,                        INTENT(IN)    :: N,L1,L2
  COMPLEX*16, DIMENSION(:,:),     INTENT(INOUT) :: H
  COMPLEX*16, DIMENSION(:,:),     INTENT(OUT)   :: Z
  DOUBLE PRECISION, DIMENSION(:), INTENT(OUT)   :: W_SPACE
  INTEGER,                        INTENT(OUT)   :: INFO
</pre></div>
</div>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SUBROUTINE MKLSPARSE_FULLEIGENVALUES(D,DV,VALUES,ROW_INDEX,COLUMN,E_L,E_R,E_FLOQUET,U_F,INFO)

!CALCULATES THE ENERGY SPECTRUM OF THE MATRIX REPRESENTED BY VALUES, ROW_INDEX AND COLUMN
! D (IN), MATRIX DIMENSION == NUMBER OF EIGENVALUES
! DV (IN), NUMBER OF VALUES != 0
! VALUES (IN) ARRAY OF VALUES
! ROW_INDEX (IN), ARRAY OF INDICES
! COLUMN (IN),    ARRAY OF COLUMN NUMBERS
! E_L (IN),       LEFT BOUNDARY OF THE SEARCH INTERVAL
! E_R (IN),       RIGHT BOUNDARY OF THE SEARCH INTERVAL
! E_FLOQUET (OUT), ARRAY OF EIGENVALUES
! INFO     (INOUT)  ERROR FLAG and VERBOSITY FLAG
!                 0 display no information
!                 1 DISPLAY INFORMAITON ABOUT THE SIZE OF THE ARRAYS
!                 10 DISPLAY INFORMAITON ABOUT THE ARRAYS AND THE ARRAYS
  USE FEAST
  IMPLICIT NONE
  INTEGER,                          INTENT(IN)    :: D,DV
  COMPLEX*16,       DIMENSION(DV),  INTENT(INOUT) :: VALUES
  INTEGER,          DIMENSION(DV),  INTENT(INOUT) :: COLUMN
  INTEGER,          DIMENSION(D+1), INTENT(INOUT) :: ROW_INDEX
  DOUBLE PRECISION,                 INTENT(IN)    :: E_L,E_R
  DOUBLE PRECISION, DIMENSION(D),   INTENT(OUT)   :: E_FLOQUET
  COMPLEX*16,       DIMENSION(D,D), INTENT(OUT)   :: U_F
  INTEGER,                          INTENT(INOUT) :: INFO
</pre></div>
</div>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SUBROUTINE</span> <span class="n">QUICK_SORT_INTEGERS</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">index_t</span><span class="p">,</span><span class="n">N</span><span class="p">)</span>

  <span class="n">IMPLICIT</span> <span class="n">NONE</span>
  <span class="n">INTEGER</span><span class="p">,</span> <span class="n">INTENT</span><span class="p">(</span><span class="n">IN</span><span class="p">)</span> <span class="p">::</span> <span class="n">N</span>
  <span class="n">INTEGER</span><span class="p">,</span> <span class="n">DIMENSION</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="n">INTENT</span><span class="p">(</span><span class="n">INOUT</span><span class="p">)</span> <span class="p">::</span> <span class="n">v</span>
  <span class="n">INTEGER</span><span class="p">,</span> <span class="n">DIMENSION</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="n">INTENT</span><span class="p">(</span><span class="n">INOUT</span><span class="p">)</span> <span class="p">::</span> <span class="n">index_t</span>

  <span class="n">INTEGER</span><span class="p">,</span> <span class="n">PARAMETER</span> <span class="p">::</span> <span class="n">NN</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">NSTACK</span><span class="o">=</span><span class="mi">8000</span>
</pre></div>
</div>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SUBROUTINE WRITE_MATRIX(A)
! it writes a matrix of doubles nxm on the screen
  DOUBLE PRECISION, DIMENSION(:,:) :: A
  CHARACTER(LEN=105) STRING
  CHARACTER(LEN=105) aux_char
  integer :: aux
</pre></div>
</div>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SUBROUTINE WRITE_MATRIX_INT(A)
!it writes a matrix of integer nxm on the screen
  INTEGER, DIMENSION(:,:) :: A
</pre></div>
</div>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SUBROUTINE</span> <span class="n">COORDINATEPACKING</span><span class="p">(</span><span class="n">D</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">V</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">C</span><span class="p">,</span><span class="n">index</span><span class="p">,</span><span class="n">INFO</span><span class="p">)</span>
  <span class="n">IMPLICIT</span> <span class="n">NONE</span>
  <span class="n">INTEGER</span><span class="p">,</span><span class="n">INTENT</span><span class="p">(</span><span class="n">IN</span><span class="p">)::</span> <span class="n">D</span>
  <span class="n">COMPLEX</span><span class="o">*</span><span class="mi">16</span><span class="p">,</span><span class="n">DIMENSION</span><span class="p">(</span><span class="n">D</span><span class="p">,</span><span class="n">D</span><span class="p">),</span><span class="n">INTENT</span><span class="p">(</span><span class="n">IN</span><span class="p">)</span>  <span class="p">::</span> <span class="n">A</span>
  <span class="n">COMPLEX</span><span class="o">*</span><span class="mi">16</span><span class="p">,</span><span class="n">DIMENSION</span><span class="p">(</span><span class="n">D</span><span class="o">*</span><span class="n">D</span><span class="p">),</span><span class="n">INTENT</span><span class="p">(</span><span class="n">OUT</span><span class="p">)</span> <span class="p">::</span> <span class="n">V</span>
  <span class="n">INTEGER</span><span class="p">,</span> <span class="n">DIMENSION</span><span class="p">(</span><span class="n">D</span><span class="o">*</span><span class="n">D</span><span class="p">),</span>  <span class="n">INTENT</span><span class="p">(</span><span class="n">OUT</span><span class="p">)</span> <span class="p">::</span> <span class="n">R</span><span class="p">,</span><span class="n">C</span>
  <span class="n">INTEGER</span><span class="p">,</span> <span class="n">INTENT</span><span class="p">(</span><span class="n">OUT</span><span class="p">)</span>   <span class="p">::</span> <span class="n">index</span>
  <span class="n">INTEGER</span><span class="p">,</span> <span class="n">INTENT</span><span class="p">(</span><span class="n">INOUT</span><span class="p">)</span> <span class="p">::</span> <span class="n">INFO</span>
</pre></div>
</div>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SUBROUTINE</span> <span class="n">APPENDARRAYS</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">INFO</span><span class="p">)</span>
  <span class="n">COMPLEX</span><span class="o">*</span><span class="mi">16</span><span class="p">,</span> <span class="n">DIMENSION</span><span class="p">(:),</span><span class="n">ALLOCATABLE</span><span class="p">,</span> <span class="n">INTENT</span><span class="p">(</span><span class="n">INOUT</span><span class="p">)</span> <span class="p">::</span> <span class="n">V</span>
  <span class="n">COMPLEX</span><span class="o">*</span><span class="mi">16</span><span class="p">,</span> <span class="n">DIMENSION</span><span class="p">(:),</span><span class="n">INTENT</span><span class="p">(</span><span class="n">IN</span><span class="p">)</span>    <span class="p">::</span> <span class="n">B</span>
  <span class="n">INTEGER</span><span class="p">,</span>                 <span class="n">INTENT</span><span class="p">(</span><span class="n">INOUT</span><span class="p">)</span> <span class="p">::</span> <span class="n">INFO</span>
</pre></div>
</div>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SUBROUTINE</span> <span class="n">APPENDARRAYSI</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">INFO</span><span class="p">)</span>
  <span class="n">INTEGER</span><span class="p">,</span> <span class="n">DIMENSION</span><span class="p">(:),</span><span class="n">ALLOCATABLE</span><span class="p">,</span> <span class="n">INTENT</span><span class="p">(</span><span class="n">INOUT</span><span class="p">)</span> <span class="p">::</span> <span class="n">V</span>
  <span class="n">INTEGER</span><span class="p">,</span> <span class="n">DIMENSION</span><span class="p">(:),</span><span class="n">INTENT</span><span class="p">(</span><span class="n">IN</span><span class="p">)</span>    <span class="p">::</span> <span class="n">B</span>
  <span class="n">INTEGER</span><span class="p">,</span>                 <span class="n">INTENT</span><span class="p">(</span><span class="n">INOUT</span><span class="p">)</span> <span class="p">::</span> <span class="n">INFO</span>
</pre></div>
</div>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SUBROUTINE</span> <span class="n">VARCRCPACKING</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">DIM</span><span class="p">,</span><span class="n">UPLO</span><span class="p">,</span><span class="n">zero</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">VALUES</span><span class="p">,</span><span class="n">COLUMNS</span><span class="p">,</span><span class="n">ROWINDEX</span><span class="p">,</span><span class="n">INFO</span><span class="p">)</span>

  <span class="n">INTEGER</span><span class="p">,</span>                   <span class="n">INTENT</span><span class="p">(</span><span class="n">IN</span><span class="p">)</span>    <span class="p">::</span> <span class="n">N</span>
  <span class="n">INTEGER</span><span class="p">,</span>                   <span class="n">INTENT</span><span class="p">(</span><span class="n">INOUT</span><span class="p">)</span> <span class="p">::</span> <span class="n">INFO</span><span class="p">,</span><span class="n">DIM</span>
  <span class="n">CHARACTER</span><span class="p">,</span>                 <span class="n">INTENT</span><span class="p">(</span><span class="n">IN</span><span class="p">)</span>    <span class="p">::</span> <span class="n">UPLO</span>
  <span class="n">DOUBLE</span> <span class="n">PRECISION</span><span class="p">,</span>          <span class="n">INTENT</span><span class="p">(</span><span class="n">IN</span><span class="p">)</span>    <span class="p">::</span> <span class="n">ZERO</span>
  <span class="n">COMPLEX</span><span class="o">*</span><span class="mi">16</span><span class="p">,</span><span class="n">DIMENSION</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">),</span> <span class="n">INTENT</span><span class="p">(</span><span class="n">IN</span><span class="p">)</span>    <span class="p">::</span> <span class="n">A</span>

  <span class="n">COMPLEX</span><span class="o">*</span><span class="mi">16</span><span class="p">,</span> <span class="n">DIMENSION</span><span class="p">(</span><span class="n">DIM</span><span class="p">),</span> <span class="n">INTENT</span><span class="p">(</span><span class="n">OUT</span><span class="p">)</span> <span class="p">::</span> <span class="n">VALUES</span>
  <span class="n">INTEGER</span><span class="p">,</span>    <span class="n">DIMENSION</span><span class="p">(</span><span class="n">DIM</span><span class="p">),</span> <span class="n">INTENT</span><span class="p">(</span><span class="n">OUT</span><span class="p">)</span> <span class="p">::</span> <span class="n">COLUMNS</span>
  <span class="n">INTEGER</span><span class="p">,</span>    <span class="n">DIMENSION</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">INTENT</span><span class="p">(</span><span class="n">OUT</span><span class="p">)</span> <span class="p">::</span> <span class="n">ROWINDEX</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="c-wrappers-prototypes-src-multimodefloquet-h">
<h1>C++ Wrappers prototypes: src/MultimodeFloquet.h<a class="headerlink" href="#c-wrappers-prototypes-src-multimodefloquet-h" title="Permalink to this headline">¶</a></h1>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">mode_c</span><span class="p">{</span>
  <span class="n">double</span> <span class="n">omega</span><span class="p">;</span>
  <span class="n">dcmplx</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">phi_x</span><span class="p">,</span><span class="n">phi_y</span><span class="p">,</span><span class="n">phi_z</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">N_Floquet</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">struct</span> <span class="n">atom_c</span><span class="p">{</span>
  <span class="nb">int</span> <span class="n">id_system</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">d_bare</span><span class="p">;</span>
<span class="p">};</span>


<span class="n">extern</span> <span class="s2">&quot;C&quot;</span> <span class="p">{</span>

  <span class="o">//</span> <span class="n">DIMENSION</span> <span class="n">OF</span> <span class="n">THE</span> <span class="n">MULTIMODE</span> <span class="n">FLOQUET</span> <span class="n">MATRIX</span><span class="o">.</span> <span class="n">CALCULATED</span> <span class="n">INTERNALLY</span>
  <span class="nb">int</span> <span class="n">h_floquet_size</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">h_floquet_c</span><span class="p">;</span> <span class="o">//</span> <span class="n">Floquet</span> <span class="n">matrix</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">bare</span> <span class="n">basis</span>

  <span class="o">//</span> <span class="n">GENERAL</span> <span class="n">INIT</span> <span class="n">SUBROUTINE</span>
  <span class="n">void</span> <span class="n">floquetinit_qubit_c_</span> <span class="p">(</span><span class="n">atom_c</span> <span class="o">*</span><span class="nb">id</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">lenght_name</span><span class="p">,</span> <span class="n">char</span> <span class="o">*</span> <span class="n">atomicspecie</span><span class="p">,</span>                                      <span class="nb">int</span> <span class="o">*</span> <span class="n">info</span><span class="p">);</span>
  <span class="n">void</span> <span class="n">floquetinit_spin_c_</span>  <span class="p">(</span><span class="n">atom_c</span> <span class="o">*</span><span class="nb">id</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">lenght_name</span><span class="p">,</span> <span class="n">char</span> <span class="o">*</span> <span class="n">atomicspecie</span><span class="p">,</span> <span class="n">double</span> <span class="o">*</span> <span class="n">jtotal</span><span class="p">,</span>                     <span class="nb">int</span> <span class="o">*</span> <span class="n">info</span><span class="p">);</span>
  <span class="n">void</span> <span class="n">floquetinit_alkali_c_</span><span class="p">(</span><span class="n">atom_c</span> <span class="o">*</span><span class="nb">id</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">lenght_name</span><span class="p">,</span> <span class="n">char</span> <span class="o">*</span> <span class="n">atomicspecie</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span> <span class="n">lenght_name2</span><span class="p">,</span> <span class="n">char</span> <span class="o">*</span> <span class="n">manifold</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span> <span class="n">info</span><span class="p">);</span>


  <span class="o">//</span> <span class="n">SET</span> <span class="n">HAMILTONIAN</span> <span class="n">OF</span> <span class="n">SPIN</span><span class="o">-</span><span class="n">LIKE</span> <span class="n">MODELS</span>
  <span class="n">void</span>  <span class="n">sethamiltoniancomponents_c_</span><span class="p">(</span><span class="n">atom_c</span> <span class="o">*</span><span class="nb">id</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">nm</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span> <span class="n">total_frequencies</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">modes_num</span><span class="p">,</span><span class="n">mode_c</span> <span class="o">*</span> <span class="n">fields</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">info</span><span class="p">);</span>


  <span class="o">//</span> <span class="n">BUILDING</span> <span class="n">FLOQUET</span> <span class="n">MATRIX</span> <span class="n">OF</span> <span class="n">GENERIC</span> <span class="n">MODEL</span>
  <span class="n">void</span>    <span class="n">multimodefloquetmatrix_c_</span>       <span class="p">(</span><span class="n">atom_c</span> <span class="o">*</span><span class="nb">id</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">nm</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span> <span class="n">total_frequencies</span><span class="p">,</span>
           <span class="nb">int</span> <span class="o">*</span> <span class="n">modes_num</span><span class="p">,</span><span class="n">mode_c</span> <span class="o">*</span> <span class="n">fields</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span> <span class="n">info</span><span class="p">);</span>
  <span class="n">void</span> <span class="n">get_h_floquet_c_</span><span class="p">(</span><span class="nb">int</span> <span class="o">*</span> <span class="n">h</span><span class="p">,</span> <span class="n">dcmplx</span> <span class="o">*</span> <span class="n">values</span><span class="p">,</span> <span class="nb">int</span><span class="o">*</span> <span class="n">info</span><span class="p">);</span>
  <span class="nb">int</span>     <span class="n">multimodefloquetmatrix_c_python_</span><span class="p">(</span><span class="n">atom_c</span> <span class="o">*</span><span class="nb">id</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">nm</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span> <span class="n">total_frequencies</span><span class="p">,</span>
          <span class="nb">int</span> <span class="o">*</span> <span class="n">modes_num</span><span class="p">,</span><span class="n">mode_c</span> <span class="o">*</span> <span class="n">fields</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">info</span><span class="p">);</span>
  <span class="n">void</span> <span class="n">multimodefloquetmatrix_sp_c_</span>       <span class="p">(</span><span class="n">atom_c</span> <span class="o">*</span><span class="nb">id</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">nm</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span> <span class="n">total_frequencies</span><span class="p">,</span>
          <span class="nb">int</span> <span class="o">*</span> <span class="n">modes_num</span><span class="p">,</span><span class="n">mode_c</span> <span class="o">*</span> <span class="n">fields</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span> <span class="n">info</span><span class="p">);</span>
  <span class="n">void</span> <span class="n">multimodefloquetmatrix_python_sp_c_</span><span class="p">(</span><span class="n">atom_c</span> <span class="o">*</span><span class="nb">id</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">nm</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span> <span class="n">total_frequencies</span><span class="p">,</span>
          <span class="nb">int</span> <span class="o">*</span> <span class="n">modes_num</span><span class="p">,</span><span class="n">mode_c</span> <span class="o">*</span> <span class="n">fields</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span> <span class="n">h_f</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">info</span><span class="p">);</span>
  <span class="n">void</span> <span class="n">get_h_floquet_sp_c_</span><span class="p">(</span><span class="nb">int</span> <span class="o">*</span> <span class="n">h_f</span><span class="p">,</span> <span class="n">dcmplx</span> <span class="o">*</span> <span class="n">values</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span> <span class="n">row_index</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span> <span class="n">column</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span> <span class="n">info</span><span class="p">);</span>


  <span class="o">//</span> <span class="n">CALCULATE</span> <span class="n">THE</span> <span class="n">SPECTRUM</span> <span class="n">OF</span> <span class="n">THE</span> <span class="n">FLOQUET</span> <span class="n">HAMILTONIAN</span>
  <span class="n">void</span>   <span class="n">lapack_fulleigenvalues_c_</span><span class="p">(</span><span class="n">dcmplx</span> <span class="o">*</span> <span class="n">u_f</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">h_floquet_size</span><span class="p">,</span>
           <span class="n">double</span> <span class="o">*</span> <span class="n">e_floquet</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
  <span class="n">void</span> <span class="n">mklsparse_fulleigenvalues_c_</span><span class="p">(</span><span class="nb">int</span> <span class="o">*</span> <span class="n">h_floquet_size</span><span class="p">,</span>
           <span class="n">double</span> <span class="o">*</span> <span class="n">e_l</span><span class="p">,</span><span class="n">double</span> <span class="o">*</span> <span class="n">e_r</span><span class="p">,</span><span class="n">double</span> <span class="o">*</span> <span class="n">e_floquet</span><span class="p">,</span><span class="n">dcmplx</span> <span class="o">*</span><span class="n">U_F</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span> <span class="n">info</span><span class="p">);</span>
  <span class="n">void</span> <span class="n">matmul_c_</span><span class="p">(</span><span class="nb">int</span> <span class="o">*</span> <span class="n">op</span><span class="p">,</span> <span class="n">dcmplx</span> <span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span> <span class="n">ra</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span> <span class="n">ca</span><span class="p">,</span>
           <span class="n">dcmplx</span> <span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span> <span class="n">rb</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span> <span class="n">cb</span><span class="p">,</span> <span class="n">dcmplx</span> <span class="o">*</span> <span class="n">c</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">info</span><span class="p">);</span>


  <span class="o">//</span> <span class="n">CONTSRUCTION</span> <span class="n">OF</span> <span class="n">THE</span> <span class="n">TIME</span><span class="o">-</span><span class="n">EVOLUTION</span> <span class="n">OPERATOR</span>
  <span class="n">void</span>         <span class="n">multimodetransitionavg_c_</span><span class="p">(</span><span class="nb">int</span> <span class="o">*</span> <span class="n">h_floquet_size</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">nm</span><span class="p">,</span><span class="n">mode_c</span> <span class="o">*</span> <span class="n">fields</span><span class="p">,</span>
      <span class="nb">int</span> <span class="o">*</span> <span class="n">modes_num</span><span class="p">,</span><span class="n">dcmplx</span> <span class="o">*</span> <span class="n">U_F</span><span class="p">,</span><span class="n">double</span> <span class="o">*</span> <span class="n">e_floquet</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">d_bare</span><span class="p">,</span><span class="n">double</span> <span class="o">*</span> <span class="n">p_avg</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
  <span class="n">void</span> <span class="n">multimodefloquettransformation_c_</span><span class="p">(</span><span class="nb">int</span> <span class="o">*</span> <span class="n">h_floquet_size</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">nm</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">modes_num</span><span class="p">,</span>
      <span class="n">dcmplx</span> <span class="o">*</span> <span class="n">U_F</span><span class="p">,</span><span class="n">double</span> <span class="o">*</span> <span class="n">e_floquet</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">d_bare</span><span class="p">,</span><span class="n">mode_c</span> <span class="o">*</span> <span class="n">fields</span><span class="p">,</span><span class="n">double</span> <span class="o">*</span> <span class="n">t1</span><span class="p">,</span><span class="n">dcmplx</span> <span class="o">*</span> <span class="n">U_B2D</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">info</span><span class="p">);</span>
  <span class="n">void</span> <span class="n">multimodemicromotion_c_</span><span class="p">(</span><span class="n">atom_c</span> <span class="o">*</span><span class="nb">id</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">h_floquet_size</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">nm</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">modes_num</span><span class="p">,</span>
      <span class="n">dcmplx</span> <span class="o">*</span> <span class="n">U_F</span><span class="p">,</span><span class="n">double</span> <span class="o">*</span> <span class="n">e_floquet</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">d_bare</span><span class="p">,</span><span class="n">mode_c</span> <span class="o">*</span> <span class="n">fields</span><span class="p">,</span><span class="n">double</span> <span class="o">*</span> <span class="n">t1</span><span class="p">,</span><span class="n">dcmplx</span> <span class="o">*</span> <span class="n">U_B2D</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">info</span><span class="p">);</span>
  <span class="n">void</span> <span class="n">multimodetimeevolutionoperator_c_</span><span class="p">(</span><span class="nb">int</span> <span class="o">*</span> <span class="n">h_floquet_size</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">nm</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">modes_num</span><span class="p">,</span>
      <span class="n">dcmplx</span> <span class="o">*</span> <span class="n">U_F</span><span class="p">,</span><span class="n">double</span> <span class="o">*</span> <span class="n">e_floquet</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">d_bare</span><span class="p">,</span><span class="n">mode_c</span> <span class="o">*</span> <span class="n">fields</span><span class="p">,</span><span class="n">double</span> <span class="o">*</span> <span class="n">t1</span><span class="p">,</span><span class="n">double</span> <span class="o">*</span> <span class="n">t2</span><span class="p">,</span><span class="n">dcmplx</span> <span class="o">*</span> <span class="n">U_AUX</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">info</span><span class="p">);</span>
  <span class="n">void</span> <span class="n">timeevolutionoperator_c_</span><span class="p">(</span><span class="n">atom_c</span> <span class="o">*</span><span class="nb">id</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">d_bare</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">nm</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">nf</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span> <span class="n">modes_num</span><span class="p">,</span>
      <span class="n">mode_c</span> <span class="o">*</span><span class="n">field</span><span class="p">,</span> <span class="n">double</span> <span class="o">*</span><span class="n">t1</span><span class="p">,</span> <span class="n">double</span> <span class="o">*</span><span class="n">t2</span><span class="p">,</span> <span class="n">dcmplx</span> <span class="o">*</span><span class="n">U</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>


  <span class="o">//</span> <span class="n">DEFINITION</span> <span class="n">OF</span> <span class="n">DRESSED</span> <span class="n">BASIS</span>
  <span class="n">void</span>            <span class="n">dressedbasis_c_</span><span class="p">(</span><span class="nb">int</span> <span class="o">*</span> <span class="n">h_floquet_size</span><span class="p">,</span><span class="n">atom_c</span> <span class="o">*</span><span class="nb">id</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">nm</span><span class="p">,</span>
                                  <span class="nb">int</span> <span class="o">*</span> <span class="n">modes_num</span><span class="p">,</span><span class="n">mode_c</span> <span class="o">*</span> <span class="n">fields</span><span class="p">,</span> <span class="n">dcmplx</span> <span class="o">*</span> <span class="n">U_FD</span><span class="p">,</span>
                                  <span class="n">double</span> <span class="o">*</span> <span class="n">e_dressed</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">info</span><span class="p">);</span>
  <span class="n">void</span>  <span class="n">dressedbasis_subset_c_</span><span class="p">(</span><span class="n">atom_c</span> <span class="o">*</span><span class="nb">id</span> <span class="p">,</span> <span class="nb">int</span> <span class="o">*</span> <span class="n">dressingfloquetdimension</span><span class="p">,</span>
                               <span class="nb">int</span> <span class="o">*</span> <span class="n">dressingfields</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span> <span class="n">nm</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span> <span class="n">dressingfields_indices</span><span class="p">,</span>
                               <span class="nb">int</span> <span class="o">*</span> <span class="n">modes_num</span><span class="p">,</span><span class="n">mode_c</span> <span class="o">*</span> <span class="n">fields</span><span class="p">,</span> <span class="n">dcmplx</span> <span class="o">*</span> <span class="n">U_FD</span><span class="p">,</span>
                               <span class="n">double</span> <span class="o">*</span> <span class="n">e_dressed</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">info</span><span class="p">);</span>
  <span class="n">void</span>  <span class="n">dressedbasis_subset_sp_c_</span><span class="p">(</span><span class="n">atom_c</span> <span class="o">*</span> <span class="nb">id</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span> <span class="n">dressingfloquetdimension</span><span class="p">,</span>
                                  <span class="nb">int</span> <span class="o">*</span> <span class="n">dressingfields</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">nm</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span> <span class="n">dressingfields_indices</span><span class="p">,</span>
                                  <span class="nb">int</span> <span class="o">*</span> <span class="n">modes_num</span><span class="p">,</span><span class="n">mode_c</span> <span class="o">*</span> <span class="n">fields</span><span class="p">,</span> <span class="n">dcmplx</span> <span class="o">*</span> <span class="n">U_FD</span><span class="p">,</span>
                                  <span class="n">double</span> <span class="o">*</span> <span class="n">e_dressed</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">info</span><span class="p">);</span>
  <span class="n">void</span>  <span class="n">dressedbasis_sp_c_</span><span class="p">(</span><span class="nb">int</span> <span class="n">h_floquet_size</span><span class="p">,</span> <span class="n">atom_c</span> <span class="o">*</span><span class="nb">id</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span> <span class="n">nm</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span> <span class="n">modes_num</span><span class="p">,</span>
                           <span class="n">mode_c</span> <span class="o">*</span> <span class="n">fields</span><span class="p">,</span> <span class="n">dcmplx</span> <span class="o">*</span> <span class="n">U_FD</span><span class="p">,</span> <span class="n">double</span> <span class="o">*</span> <span class="n">e_dressed</span><span class="p">,</span>
                           <span class="nb">int</span> <span class="o">*</span> <span class="n">info</span><span class="p">);</span>
  <span class="n">void</span> <span class="n">micromotionfourierdressedbasis_c_</span><span class="p">(</span><span class="n">atom_c</span> <span class="o">*</span><span class="nb">id</span> <span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">DF</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span> <span class="n">dressingfields_indices</span><span class="p">,</span>
                                         <span class="nb">int</span> <span class="o">*</span> <span class="n">nm</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span> <span class="n">modes_num</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">nf</span><span class="p">,</span> <span class="n">mode_c</span> <span class="o">*</span> <span class="n">fields</span><span class="p">,</span>
                                         <span class="nb">int</span> <span class="o">*</span> <span class="n">nd</span><span class="p">,</span><span class="n">dcmplx</span> <span class="o">*</span> <span class="n">U_FD</span><span class="p">,</span> <span class="n">double</span> <span class="o">*</span><span class="n">e_dressed</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">info</span><span class="p">);</span>
  <span class="n">void</span> <span class="n">micromotiondressedbasis_c_</span><span class="p">(</span><span class="n">atom_c</span> <span class="o">*</span><span class="nb">id</span> <span class="p">,</span> <span class="nb">int</span> <span class="o">*</span> <span class="n">modes_num</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span> <span class="n">dressingfields_indices</span><span class="p">,</span>
                                  <span class="n">mode_c</span> <span class="o">*</span> <span class="n">fields</span><span class="p">,</span> <span class="n">double</span> <span class="n">T1</span><span class="p">,</span> <span class="n">dcmplx</span> <span class="o">*</span> <span class="n">U</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span> <span class="n">info</span><span class="p">);</span>


  <span class="o">//</span> <span class="n">UTILITY</span> <span class="n">FUNCTIONS</span><span class="p">:</span> <span class="n">WRITE</span> <span class="n">MATRICES</span> <span class="n">ON</span> <span class="n">THE</span> <span class="n">SCREEN</span>
  <span class="n">void</span> <span class="n">write_matrix_c_</span><span class="p">(</span><span class="n">double</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">A_dim</span><span class="p">);</span>
  <span class="n">void</span> <span class="n">rec_write_matrix_c_</span><span class="p">(</span><span class="n">double</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span> <span class="n">A_dim1</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span> <span class="n">A_dim2</span><span class="p">);</span>


  <span class="o">//</span> <span class="n">deallocate</span> <span class="nb">all</span> <span class="n">arrays</span> <span class="n">allocated</span> <span class="k">with</span> <span class="n">fortran</span>
  <span class="n">void</span> <span class="n">deallocateall_c_</span><span class="p">(</span><span class="nb">int</span> <span class="o">*</span><span class="nb">id</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="python-wrappers-prototypes">
<h1>Python Wrappers prototypes<a class="headerlink" href="#python-wrappers-prototypes" title="Permalink to this headline">¶</a></h1>
<div class="line-block">
<div class="line">OPENMMF includes a set of wrappers to use the library with Python,
defined in the file src/openmmf.py , The wrapper use CTYPES to pass on
parameters to the C++ wrappers. In order for this to work, you should
make sure that the openmmf dynamical library is loaded correctly, e.g.
using the instruction:</div>
<div class="line">openmmfC=ctypes.CDLL(’../lib/libmultimodefloquet.so’)</div>
<div class="line">near the top of src/openmmf.py . Make sure the path is correct.</div>
</div>
<p>The wrappers were developed and tested using: Python 3.7.6, ctypes
1.1.0, numpy 1.16.2, scipy 1.4.1 and matplotlib 3.0.3.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#===================================================================</span>
<span class="c1">#   // GENERAL CLASSES</span>
<span class="c1">#===================================================================</span>


<span class="k">class</span> <span class="nc">atom_c_T</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="s2">&quot;id_system&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;d_bare&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)</span>
            <span class="p">]</span>

<span class="c1">#===================================================================</span>
<span class="c1">#===================================================================</span>

<span class="k">class</span> <span class="nc">mode_c_T</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">c_dcmplx</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="o">*</span><span class="mi">2</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="s2">&quot;omega&quot;</span><span class="p">,</span>     <span class="n">c_double</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span>         <span class="n">c_dcmplx</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span>         <span class="n">c_dcmplx</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,</span>         <span class="n">c_dcmplx</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;phi_x&quot;</span><span class="p">,</span>     <span class="n">c_double</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;phi_y&quot;</span><span class="p">,</span>     <span class="n">c_double</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;phi_z&quot;</span><span class="p">,</span>     <span class="n">c_double</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;N_Floquet&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)</span>
            <span class="p">]</span>



<span class="c1">#===================================================================</span>
<span class="c1">#   // GENERAL INIT SUBROUTINE</span>
<span class="c1">#===================================================================</span>

<span class="n">openmmf</span><span class="o">.</span><span class="n">floquetinit</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="o">*</span><span class="n">argsv</span><span class="p">,</span><span class="n">info</span><span class="p">):</span>
        <span class="n">Parameters</span><span class="p">:</span> <span class="nb">id</span><span class="p">:</span> <span class="n">atom_c_T</span>
                       <span class="n">Identifies</span> <span class="n">the</span> <span class="nb">type</span> <span class="n">of</span> <span class="n">system</span>
                    <span class="o">*</span><span class="n">argsv</span><span class="p">:</span> <span class="n">array</span>
                       <span class="n">Depending</span> <span class="n">on</span> <span class="n">the</span> <span class="n">system</span> <span class="n">of</span> <span class="n">inters</span>
                    <span class="n">info</span><span class="p">:</span> <span class="nb">int</span>
                       <span class="n">Error</span><span class="o">/</span><span class="n">success</span> <span class="n">flag</span>

<span class="n">This</span> <span class="n">function</span> <span class="n">supports</span> <span class="n">the</span> <span class="n">following</span> <span class="n">calls</span><span class="p">:</span>

<span class="n">openmmf</span><span class="o">.</span><span class="n">floquetinit</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">qubit</span><span class="p">,</span><span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">)</span>
       <span class="n">qubit</span><span class="p">:</span> <span class="nb">str</span>
             <span class="s1">&#39;qubit&#39;</span> <span class="n">to</span> <span class="n">define</span> <span class="n">a</span> <span class="n">two</span><span class="o">-</span><span class="n">level</span> <span class="n">system</span>
       <span class="n">info</span><span class="p">:</span> <span class="nb">int</span>
             <span class="n">Error</span><span class="o">/</span><span class="n">success</span> <span class="n">flag</span>

<span class="n">openmmf</span><span class="o">.</span><span class="n">floquetinit</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">alkali</span><span class="p">,</span><span class="n">manifold</span><span class="p">,</span><span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">)</span>
        <span class="n">alkali</span><span class="p">:</span> <span class="nb">str</span>
                <span class="s1">&#39;87Rb&#39;</span><span class="p">,</span> <span class="s1">&#39;23Na&#39;</span> <span class="n">atomic</span> <span class="n">specie</span>
        <span class="n">manifold</span><span class="p">:</span> <span class="nb">str</span>
                 <span class="n">Manifold</span> <span class="n">of</span> <span class="n">the</span> <span class="n">hyperfine</span> <span class="n">splitting</span>
                <span class="s1">&#39;L&#39;</span> <span class="p">:</span> <span class="n">Lower</span> <span class="k">with</span> <span class="n">total</span> <span class="n">angular</span> <span class="n">moment</span> <span class="n">F</span> <span class="o">=</span> <span class="n">I</span><span class="o">-</span><span class="n">J</span>
                <span class="s1">&#39;U&#39;</span> <span class="p">:</span> <span class="n">Upper</span> <span class="k">with</span> <span class="n">total</span> <span class="n">angular</span> <span class="n">momentum</span> <span class="n">F</span><span class="o">=</span> <span class="n">I</span><span class="o">+</span><span class="n">J</span>
                <span class="s1">&#39;B&#39;</span> <span class="p">:</span> <span class="n">both</span> <span class="n">manifods</span>
       <span class="n">info</span><span class="p">:</span> <span class="nb">int</span>
             <span class="n">Error</span><span class="o">/</span><span class="n">success</span> <span class="n">flag</span>


<span class="n">openmmf</span><span class="o">.</span><span class="n">floquetinit</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">system</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">)</span>
        <span class="n">system</span><span class="p">:</span> <span class="nb">str</span>
                <span class="s1">&#39;spin&#39;</span>   <span class="n">single</span> <span class="n">particle</span> <span class="k">with</span> <span class="n">total</span> <span class="n">angular</span> <span class="n">momentum</span> <span class="mi">2</span><span class="o">*</span><span class="n">L</span>
                <span class="s1">&#39;lattice&#39;</span> <span class="n">quantum</span> <span class="n">system</span> <span class="k">with</span> <span class="n">L</span> <span class="n">sites</span><span class="o">/</span><span class="n">states</span>
        <span class="n">L</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span>
                <span class="n">define</span>
       <span class="n">info</span><span class="p">:</span> <span class="nb">int</span>
             <span class="n">Error</span><span class="o">/</span><span class="n">success</span> <span class="n">flag</span>


<span class="c1">#===================================================================</span>
<span class="c1">#   EVALUATE THE HAMILTONIAN COMPONENTS OF PRE-DEFINED SYSTEMS.</span>
<span class="c1">#===================================================================</span>
<span class="n">openmmf</span><span class="o">.</span><span class="n">sethamiltoniancomponents</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">modes_num</span><span class="p">,</span><span class="n">fields</span><span class="p">,</span><span class="n">info</span><span class="p">):</span>
        <span class="nb">id</span><span class="p">:</span> <span class="n">atom_c_T</span> <span class="n">instance</span>
        <span class="n">modes_num</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
               <span class="n">define</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="n">fundamental</span> <span class="n">frequencies</span> <span class="ow">and</span> <span class="n">modes</span>
               <span class="n">the</span> <span class="n">total</span> <span class="n">number</span> <span class="n">of</span> <span class="n">modes</span> <span class="ow">is</span> <span class="n">nm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">modes_num</span><span class="p">)</span>
        <span class="n">fields</span><span class="p">:</span> <span class="n">instance</span> <span class="n">of</span> <span class="n">openmmf</span><span class="o">.</span><span class="n">mode_c_T</span><span class="o">*</span><span class="n">nm</span>
               <span class="n">equivalent</span> <span class="n">to</span> <span class="n">the</span> <span class="n">FORTRAN</span> <span class="n">data</span> <span class="n">derived</span> <span class="nb">type</span> <span class="n">FIELDS</span>
        <span class="n">info</span><span class="p">:</span> <span class="nb">int</span>
             <span class="n">Error</span><span class="o">/</span><span class="n">success</span> <span class="n">flag</span>

<span class="c1">#===================================================================</span>
<span class="c1">#   // BUILDING FLOQUET MATRIX OF GENERIC MODEL</span>
<span class="c1">#===================================================================</span>
<span class="n">openmmf</span><span class="o">.</span><span class="n">multimodefloquetmatrix</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">modes_num</span><span class="p">,</span><span class="n">fields</span><span class="p">,</span><span class="n">info</span><span class="p">):</span>
        <span class="nb">id</span><span class="p">:</span> <span class="n">atom_c_T</span> <span class="n">instance</span>
        <span class="n">modes_num</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
               <span class="n">define</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="n">fundamental</span> <span class="n">frequencies</span> <span class="ow">and</span> <span class="n">modes</span>
               <span class="n">the</span> <span class="n">total</span> <span class="n">number</span> <span class="n">of</span> <span class="n">modes</span> <span class="ow">is</span> <span class="n">nm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">modes_num</span><span class="p">)</span>
        <span class="n">fields</span><span class="p">:</span> <span class="n">instance</span> <span class="n">of</span> <span class="n">openmmf</span><span class="o">.</span><span class="n">mode_c_T</span><span class="o">*</span><span class="n">nm</span>
               <span class="n">equivalent</span> <span class="n">to</span> <span class="n">the</span> <span class="n">FORTRAN</span> <span class="n">data</span> <span class="n">derived</span> <span class="nb">type</span> <span class="n">FIELDS</span>
        <span class="n">info</span><span class="p">:</span> <span class="nb">int</span>
             <span class="n">Error</span><span class="o">/</span><span class="n">success</span> <span class="n">flag</span>


<span class="n">openmmf</span><span class="o">.</span><span class="n">get_h_floquet</span><span class="p">(</span><span class="n">h_floquet_size</span><span class="p">,</span> <span class="n">info</span><span class="p">):</span>
        <span class="n">h_floquet_size</span><span class="p">:</span> <span class="nb">int</span>
               <span class="n">size</span> <span class="n">of</span> <span class="n">the</span> <span class="n">multimode</span> <span class="n">Floquet</span> <span class="n">matrx</span>
        <span class="n">returns</span> <span class="n">the</span> <span class="n">multimode</span> <span class="n">floquet</span> <span class="n">matrix</span>

<span class="n">openmmf</span><span class="o">.</span><span class="n">multimodefloquetmatrix_sp</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">modes_num</span><span class="p">,</span><span class="n">fields</span><span class="p">,</span><span class="n">info</span><span class="p">):</span>
        <span class="nb">id</span><span class="p">:</span> <span class="n">atom_c_T</span> <span class="n">instance</span>
        <span class="n">modes_num</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
               <span class="n">define</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="n">fundamental</span> <span class="n">frequencies</span> <span class="ow">and</span> <span class="n">modes</span>
               <span class="n">the</span> <span class="n">total</span> <span class="n">number</span> <span class="n">of</span> <span class="n">modes</span> <span class="ow">is</span> <span class="n">nm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">modes_num</span><span class="p">)</span>
        <span class="n">fields</span><span class="p">:</span> <span class="n">instance</span> <span class="n">of</span> <span class="n">openmmf</span><span class="o">.</span><span class="n">mode_c_T</span><span class="o">*</span><span class="n">nm</span>
               <span class="n">equivalent</span> <span class="n">to</span> <span class="n">the</span> <span class="n">FORTRAN</span> <span class="n">data</span> <span class="n">derived</span> <span class="nb">type</span> <span class="n">FIELDS</span>
        <span class="n">info</span><span class="p">:</span> <span class="nb">int</span>
             <span class="n">Error</span><span class="o">/</span><span class="n">success</span> <span class="n">flag</span>

<span class="n">openmmf</span><span class="o">.</span><span class="n">get_h_floquet_sp</span><span class="p">(</span><span class="n">h_floquet_size</span><span class="p">,</span> <span class="n">info</span><span class="p">):</span>
        <span class="n">h_floquet_size</span><span class="p">:</span> <span class="nb">int</span>
               <span class="n">size</span> <span class="n">of</span> <span class="n">the</span> <span class="n">multimode</span> <span class="n">Floquet</span> <span class="n">matrx</span>
        <span class="n">returns</span> <span class="n">VALUE</span><span class="p">,</span><span class="n">ROW</span><span class="p">,</span><span class="n">COLUMN</span> <span class="n">arrays</span> <span class="n">to</span> <span class="n">represent</span> <span class="n">a</span> <span class="n">sparse</span> <span class="n">multimode</span> <span class="n">floquet</span> <span class="n">matrix</span>

<span class="c1">#===================================================================</span>
<span class="c1">#  // CALCULATE THE SPECTRUM OF THE FLOQUET HAMILTONIAN</span>
<span class="c1">#===================================================================</span>
<span class="n">openmmf</span><span class="o">.</span><span class="n">lapack_fulleigenvalues</span><span class="p">(</span><span class="n">U_F</span><span class="p">,</span><span class="n">h_floquet_size</span><span class="p">,</span><span class="n">e_floquet</span><span class="p">,</span><span class="n">info</span><span class="p">):</span>
        <span class="n">U_F</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
             <span class="n">h_floquet_size</span> <span class="n">x</span> <span class="n">h_floquet_size</span> <span class="n">matrix</span> <span class="n">of</span> <span class="n">eigenvectors</span>
        <span class="n">h_floquet_size</span><span class="p">:</span> <span class="nb">int</span>
               <span class="n">size</span> <span class="n">of</span> <span class="n">the</span> <span class="n">multimode</span> <span class="n">Floquet</span> <span class="n">matrx</span>
        <span class="n">e_floquet</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
               <span class="n">array</span> <span class="n">of</span> <span class="n">size</span> <span class="n">h_floquet_size</span> <span class="n">containing</span> <span class="n">the</span> <span class="n">eigenvalues</span> <span class="n">of</span>
               <span class="n">the</span> <span class="n">multimode</span> <span class="n">Floquet</span> <span class="n">Hamiltonian</span>
        <span class="n">info</span><span class="p">:</span> <span class="nb">int</span>
             <span class="n">Error</span><span class="o">/</span><span class="n">success</span> <span class="n">flag</span>

<span class="c1">#===================================================================</span>
<span class="c1">#   EVALUATES THE TIME AVERAGE TRANSITIONS PROBABILITIES</span>
<span class="c1">#===================================================================</span>
<span class="n">openmmf</span><span class="o">.</span><span class="n">multimodetransitionavg</span><span class="p">(</span><span class="n">h_floquet_size</span><span class="p">,</span><span class="n">fields</span><span class="p">,</span><span class="n">modes_num</span><span class="p">,</span><span class="n">U_F</span><span class="p">,</span><span class="n">e_floquet</span><span class="p">,</span><span class="n">d_bare</span><span class="p">,</span><span class="n">p_avg</span><span class="p">,</span><span class="n">info</span><span class="p">):</span>
        <span class="n">h_floquet_size</span><span class="p">:</span> <span class="nb">int</span>
               <span class="n">size</span> <span class="n">of</span> <span class="n">the</span> <span class="n">multimode</span> <span class="n">Floquet</span> <span class="n">matrx</span>
        <span class="n">fields</span><span class="p">:</span> <span class="n">instance</span> <span class="n">of</span> <span class="n">openmmf</span><span class="o">.</span><span class="n">mode_c_T</span><span class="o">*</span><span class="n">nm</span>
               <span class="n">equivalent</span> <span class="n">to</span> <span class="n">the</span> <span class="n">FORTRAN</span> <span class="n">data</span> <span class="n">derived</span> <span class="nb">type</span> <span class="n">FIELDS</span>
        <span class="n">modes_num</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
               <span class="n">define</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="n">fundamental</span> <span class="n">frequencies</span> <span class="ow">and</span> <span class="n">modes</span>
               <span class="n">the</span> <span class="n">total</span> <span class="n">number</span> <span class="n">of</span> <span class="n">modes</span> <span class="ow">is</span> <span class="n">nm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">modes_num</span><span class="p">)</span>
        <span class="n">U_F</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
             <span class="n">h_floquet_size</span> <span class="n">x</span> <span class="n">h_floquet_size</span> <span class="n">matrix</span> <span class="n">of</span> <span class="n">eigenvectors</span>
        <span class="n">e_floquet</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
               <span class="n">array</span> <span class="n">containing</span> <span class="n">the</span> <span class="n">eigenvalues</span> <span class="n">of</span> <span class="n">the</span> <span class="n">multimode</span> <span class="n">Floquet</span>
               <span class="n">Hamiltonian</span>
        <span class="n">d_bare</span><span class="p">:</span> <span class="nb">int</span>
              <span class="n">Hilbert</span> <span class="n">space</span> <span class="n">dimension</span> <span class="n">of</span> <span class="n">the</span> <span class="n">static</span> <span class="n">system</span>
        <span class="n">p_avg</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
             <span class="n">d_bare</span> <span class="n">x</span> <span class="n">d_bare</span> <span class="n">Matrix</span> <span class="n">of</span> <span class="n">the</span> <span class="n">time</span><span class="o">-</span><span class="n">average</span> <span class="n">state</span> <span class="n">occupationrs</span>
        <span class="n">info</span><span class="p">:</span> <span class="nb">int</span>
             <span class="n">Error</span><span class="o">/</span><span class="n">success</span> <span class="n">flag</span>

<span class="c1">#===================================================================</span>
<span class="c1"># FOURIER COMPONENTS OF THE TRANSFORMATION BETWEEN THE DRESSED AND THE BARE BASIS</span>
<span class="c1"># U_B2D is of dimension [D_bare*D_floquet]</span>
<span class="c1">#===================================================================</span>
<span class="n">openmmf</span><span class="o">.</span><span class="n">multimodefloquettransformation</span><span class="p">(</span><span class="n">modes_num</span><span class="p">,</span> <span class="n">U_F</span><span class="p">,</span><span class="n">e_floquet</span><span class="p">,</span><span class="n">d_bare</span><span class="p">,</span><span class="n">fields</span><span class="p">,</span><span class="n">t1</span><span class="p">,</span> <span class="n">U_B2D</span><span class="p">,</span><span class="n">info</span><span class="p">):</span>
        <span class="n">modes_num</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
               <span class="n">define</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="n">fundamental</span> <span class="n">frequencies</span> <span class="ow">and</span> <span class="n">modes</span>
               <span class="n">the</span> <span class="n">total</span> <span class="n">number</span> <span class="n">of</span> <span class="n">modes</span> <span class="ow">is</span> <span class="n">nm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">modes_num</span><span class="p">)</span>
        <span class="n">U_F</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
             <span class="n">h_floquet_size</span> <span class="n">x</span> <span class="n">h_floquet_size</span> <span class="n">Matrix</span> <span class="n">of</span> <span class="n">eigenvectors</span>
        <span class="n">e_floquet</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
               <span class="n">array</span> <span class="n">containing</span> <span class="n">the</span> <span class="n">eigenvalues</span> <span class="n">of</span> <span class="n">the</span> <span class="n">multimode</span> <span class="n">Floquet</span>
               <span class="n">Hamiltonian</span>
        <span class="n">d_bare</span><span class="p">:</span> <span class="nb">int</span>
              <span class="n">Hilbert</span> <span class="n">space</span> <span class="n">dimension</span> <span class="n">of</span> <span class="n">the</span> <span class="n">static</span> <span class="n">system</span>
        <span class="n">fields</span><span class="p">:</span> <span class="n">instance</span> <span class="n">of</span> <span class="n">openmmf</span><span class="o">.</span><span class="n">mode_c_T</span><span class="o">*</span><span class="n">nm</span>
               <span class="n">equivalent</span> <span class="n">to</span> <span class="n">the</span> <span class="n">FORTRAN</span> <span class="n">data</span> <span class="n">derived</span> <span class="nb">type</span> <span class="n">FIELDS</span>
        <span class="n">t1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span>
             <span class="n">instant</span> <span class="n">of</span> <span class="n">time</span> <span class="n">to</span> <span class="n">evaluate</span> <span class="n">the</span> <span class="n">micromotion</span> <span class="n">operator</span>
        <span class="n">U_B2D</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
             <span class="n">d_bare</span> <span class="n">x</span> <span class="n">d_bare</span> <span class="n">Matrix</span> <span class="n">of</span> <span class="n">the</span> <span class="n">time</span><span class="o">-</span><span class="n">average</span> <span class="n">state</span> <span class="n">occupationrs</span>
        <span class="n">info</span><span class="p">:</span> <span class="nb">int</span>
             <span class="n">Error</span><span class="o">/</span><span class="n">success</span> <span class="n">flag</span>


<span class="c1">#===================================================================</span>
<span class="c1"># CALCULATE THE MICROMOTION OPERATOR</span>
<span class="c1"># U_B2D is of dimension [D_bare*D_bare]</span>
<span class="c1">#===================================================================</span>
<span class="n">openmmf</span><span class="o">.</span><span class="n">multimodemicromotion</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">h_floquet_size</span><span class="p">,</span><span class="n">modes_num</span><span class="p">,</span><span class="n">U_F</span><span class="p">,</span><span class="n">e_floquet</span><span class="p">,</span><span class="n">d_bare</span><span class="p">,</span><span class="n">fields</span><span class="p">,</span><span class="n">t1</span><span class="p">,</span> <span class="n">U_B2D</span><span class="p">,</span><span class="n">info</span><span class="p">):</span>
        <span class="nb">id</span><span class="p">:</span> <span class="n">atom_c_T</span> <span class="n">instance</span>
        <span class="n">h_floquet_size</span><span class="p">:</span> <span class="nb">int</span>
               <span class="n">size</span> <span class="n">of</span> <span class="n">the</span> <span class="n">multimode</span> <span class="n">Floquet</span> <span class="n">matrx</span>
        <span class="n">modes_num</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
               <span class="n">define</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="n">fundamental</span> <span class="n">frequencies</span> <span class="ow">and</span> <span class="n">modes</span>
               <span class="n">the</span> <span class="n">total</span> <span class="n">number</span> <span class="n">of</span> <span class="n">modes</span> <span class="ow">is</span> <span class="n">nm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">modes_num</span><span class="p">)</span>
        <span class="n">U_F</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
             <span class="n">h_floquet_size</span> <span class="n">x</span> <span class="n">h_floquet_size</span> <span class="n">Matrix</span> <span class="n">of</span> <span class="n">eigenvectors</span>
        <span class="n">e_floquet</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
               <span class="n">array</span> <span class="n">containing</span> <span class="n">the</span> <span class="n">eigenvalues</span> <span class="n">of</span> <span class="n">the</span> <span class="n">multimode</span> <span class="n">Floquet</span>
               <span class="n">Hamiltonian</span>
        <span class="n">d_bare</span><span class="p">:</span> <span class="nb">int</span>
              <span class="n">Hilbert</span> <span class="n">space</span> <span class="n">dimension</span> <span class="n">of</span> <span class="n">the</span> <span class="n">static</span> <span class="n">system</span>
        <span class="n">fields</span><span class="p">:</span> <span class="n">instance</span> <span class="n">of</span> <span class="n">openmmf</span><span class="o">.</span><span class="n">mode_c_T</span><span class="o">*</span><span class="n">nm</span>
               <span class="n">equivalent</span> <span class="n">to</span> <span class="n">the</span> <span class="n">FORTRAN</span> <span class="n">data</span> <span class="n">derived</span> <span class="nb">type</span> <span class="n">FIELDS</span>
        <span class="n">t1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span>
             <span class="n">instant</span> <span class="n">of</span> <span class="n">time</span> <span class="n">to</span> <span class="n">evaluate</span> <span class="n">the</span> <span class="n">micromotion</span> <span class="n">operator</span>
        <span class="n">U_B2D</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
             <span class="n">d_bare</span> <span class="n">x</span> <span class="n">d_bare</span> <span class="n">Matrix</span> <span class="n">of</span> <span class="n">the</span> <span class="n">time</span><span class="o">-</span><span class="n">average</span> <span class="n">state</span> <span class="n">occupationrs</span>
        <span class="n">info</span><span class="p">:</span> <span class="nb">int</span>
             <span class="n">Error</span><span class="o">/</span><span class="n">success</span> <span class="n">flag</span>

<span class="c1">#===================================================================</span>
<span class="c1"># COMP. ROUTINE: EVALUATE THE TIME EVOULUTION OPERATOR BETWEEN T1 AND T2</span>
<span class="c1"># USING THE FOURIER DECOMPOSITION</span>
<span class="c1"># OF THE MICROMOTION OPERATOR, WHICH IS STORE IN U_F.</span>
<span class="c1">#===================================================================</span>
<span class="k">def</span> <span class="nf">multimodetimeevolutionoperator</span><span class="p">(</span><span class="n">h_floquet_size</span><span class="p">,</span><span class="n">modes_num</span><span class="p">,</span><span class="n">U_F</span><span class="p">,</span><span class="n">e_floquet</span><span class="p">,</span><span class="n">d_bare</span><span class="p">,</span>
            <span class="n">fields</span><span class="p">,</span><span class="n">t1</span><span class="p">,</span><span class="n">t2</span><span class="p">,</span><span class="n">U_AUX</span><span class="p">,</span><span class="n">info</span><span class="p">):</span>
        <span class="n">h_floquet_size</span><span class="p">:</span> <span class="nb">int</span>
               <span class="n">size</span> <span class="n">of</span> <span class="n">the</span> <span class="n">multimode</span> <span class="n">Floquet</span> <span class="n">matrx</span>
        <span class="n">modes_num</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
               <span class="n">define</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="n">fundamental</span> <span class="n">frequencies</span> <span class="ow">and</span> <span class="n">modes</span>
               <span class="n">the</span> <span class="n">total</span> <span class="n">number</span> <span class="n">of</span> <span class="n">modes</span> <span class="ow">is</span> <span class="n">nm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">modes_num</span><span class="p">)</span>
        <span class="n">U_F</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
             <span class="n">h_floquet_size</span> <span class="n">x</span> <span class="n">h_floquet_size</span> <span class="n">Matrix</span> <span class="n">of</span> <span class="n">eigenvectors</span>
        <span class="n">e_floquet</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
               <span class="n">array</span> <span class="n">containing</span> <span class="n">the</span> <span class="n">eigenvalues</span> <span class="n">of</span> <span class="n">the</span> <span class="n">multimode</span> <span class="n">Floquet</span>
               <span class="n">Hamiltonian</span>
        <span class="n">d_bare</span><span class="p">:</span> <span class="nb">int</span>
              <span class="n">Hilbert</span> <span class="n">space</span> <span class="n">dimension</span> <span class="n">of</span> <span class="n">the</span> <span class="n">static</span> <span class="n">system</span>
        <span class="n">fields</span><span class="p">:</span> <span class="n">instance</span> <span class="n">of</span> <span class="n">openmmf</span><span class="o">.</span><span class="n">mode_c_T</span><span class="o">*</span><span class="n">nm</span>
               <span class="n">equivalent</span> <span class="n">to</span> <span class="n">the</span> <span class="n">FORTRAN</span> <span class="n">data</span> <span class="n">derived</span> <span class="nb">type</span> <span class="n">FIELDS</span>
        <span class="n">t1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span>
             <span class="n">instant</span> <span class="n">of</span> <span class="n">time</span> <span class="n">to</span> <span class="n">evaluate</span> <span class="n">the</span> <span class="n">time</span><span class="o">-</span><span class="n">evolution</span> <span class="n">operator</span>
        <span class="n">t2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span>
             <span class="n">instant</span> <span class="n">of</span> <span class="n">time</span> <span class="n">to</span> <span class="n">evaluate</span> <span class="n">the</span> <span class="n">time</span><span class="o">-</span><span class="n">evolution</span> <span class="n">operator</span>
        <span class="n">U_AUX</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
             <span class="n">d_bare</span> <span class="n">x</span> <span class="n">d_bare</span> <span class="n">Matrix</span> <span class="n">of</span> <span class="n">the</span> <span class="n">time</span><span class="o">-</span><span class="n">evolution</span> <span class="n">operator</span>
        <span class="n">info</span><span class="p">:</span> <span class="nb">int</span>
             <span class="n">Error</span><span class="o">/</span><span class="n">success</span> <span class="n">flag</span>


<span class="c1">#===================================================================</span>
<span class="c1"># DRIVER ROUTINE: EVALUATE THE TIME EVOULUTION OPERATOR BETWEEN T1 AND T2</span>
<span class="c1">#===================================================================</span>
<span class="k">def</span> <span class="nf">timeevolutionoperator</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">d_bare</span><span class="p">,</span><span class="n">modes_num</span><span class="p">,</span><span class="n">fields</span><span class="p">,</span><span class="n">t1</span><span class="p">,</span><span class="n">t2</span><span class="p">,</span><span class="n">U</span><span class="p">,</span><span class="n">info</span><span class="p">):</span>
        <span class="nb">id</span><span class="p">:</span> <span class="n">atom_c_T</span> <span class="n">instance</span>
        <span class="n">d_bare</span><span class="p">:</span> <span class="nb">int</span>
              <span class="n">Hilbert</span> <span class="n">space</span> <span class="n">dimension</span> <span class="n">of</span> <span class="n">the</span> <span class="n">static</span> <span class="n">system</span>
        <span class="n">modes_num</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
               <span class="n">define</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="n">fundamental</span> <span class="n">frequencies</span> <span class="ow">and</span> <span class="n">modes</span>
               <span class="n">the</span> <span class="n">total</span> <span class="n">number</span> <span class="n">of</span> <span class="n">modes</span> <span class="ow">is</span> <span class="n">nm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">modes_num</span><span class="p">)</span>
        <span class="n">fields</span><span class="p">:</span> <span class="n">instance</span> <span class="n">of</span> <span class="n">openmmf</span><span class="o">.</span><span class="n">mode_c_T</span><span class="o">*</span><span class="n">nm</span>
               <span class="n">equivalent</span> <span class="n">to</span> <span class="n">the</span> <span class="n">FORTRAN</span> <span class="n">data</span> <span class="n">derived</span> <span class="nb">type</span> <span class="n">FIELDS</span>
        <span class="n">t1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span>
             <span class="n">instant</span> <span class="n">of</span> <span class="n">time</span> <span class="n">to</span> <span class="n">evaluate</span> <span class="n">the</span> <span class="n">time</span> <span class="n">evolution</span> <span class="n">operator</span>
        <span class="n">t2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span>
             <span class="n">instant</span> <span class="n">of</span> <span class="n">time</span> <span class="n">to</span> <span class="n">evaluate</span> <span class="n">the</span> <span class="n">time</span> <span class="n">evolution</span> <span class="n">operator</span>
        <span class="n">U</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
             <span class="n">d_bare</span> <span class="n">x</span> <span class="n">d_bare</span> <span class="n">Matrix</span> <span class="n">of</span> <span class="n">the</span> <span class="n">time</span><span class="o">-</span><span class="n">evolution</span> <span class="n">operator</span>
        <span class="n">info</span><span class="p">:</span> <span class="nb">int</span>
             <span class="n">Error</span><span class="o">/</span><span class="n">success</span> <span class="n">flag</span>


<span class="c1">#===================================================================</span>
<span class="c1">#  // DEFINITION OF DRESSED BASIS WITH ALL FIELDS</span>
<span class="c1">#===================================================================</span>
<span class="k">def</span> <span class="nf">dressedbasis</span><span class="p">(</span><span class="n">h_floquet_size</span><span class="p">,</span><span class="nb">id</span><span class="p">,</span><span class="n">modes_num</span><span class="p">,</span><span class="n">fields</span><span class="p">,</span><span class="n">U_FD</span><span class="p">,</span><span class="n">e_dressed</span><span class="p">,</span><span class="n">info</span><span class="p">):</span>
        <span class="n">h_floquet_size</span><span class="p">:</span> <span class="nb">int</span>
               <span class="n">size</span> <span class="n">of</span> <span class="n">the</span> <span class="n">multimode</span> <span class="n">Floquet</span> <span class="n">matrx</span>
        <span class="nb">id</span><span class="p">:</span> <span class="n">atom_c_T</span> <span class="n">instance</span>
        <span class="n">modes_num</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
               <span class="n">define</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="n">fundamental</span> <span class="n">frequencies</span> <span class="ow">and</span> <span class="n">modes</span>
               <span class="n">the</span> <span class="n">total</span> <span class="n">number</span> <span class="n">of</span> <span class="n">modes</span> <span class="ow">is</span> <span class="n">nm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">modes_num</span><span class="p">)</span>
        <span class="n">fields</span><span class="p">:</span> <span class="n">instance</span> <span class="n">of</span> <span class="n">openmmf</span><span class="o">.</span><span class="n">mode_c_T</span><span class="o">*</span><span class="n">nm</span>
               <span class="n">equivalent</span> <span class="n">to</span> <span class="n">the</span> <span class="n">FORTRAN</span> <span class="n">data</span> <span class="n">derived</span> <span class="nb">type</span> <span class="n">FIELDS</span>
        <span class="n">U_FD</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
             <span class="n">d_bare</span> <span class="n">x</span> <span class="n">d_bare</span> <span class="n">Matrix</span> <span class="n">of</span> <span class="n">the</span> <span class="n">time</span><span class="o">-</span><span class="n">average</span> <span class="n">state</span> <span class="n">occupationrs</span>
        <span class="n">e_dressed</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
               <span class="n">array</span> <span class="n">containing</span> <span class="n">the</span> <span class="n">eigenvalues</span> <span class="n">of</span> <span class="n">the</span> <span class="n">multimode</span> <span class="n">Floquet</span>
               <span class="n">Hamiltonian</span>
        <span class="n">info</span><span class="p">:</span> <span class="nb">int</span>
             <span class="n">Error</span><span class="o">/</span><span class="n">success</span> <span class="n">flag</span>

<span class="k">def</span> <span class="nf">dressedbasis_sp</span><span class="p">(</span><span class="n">h_floquet_size</span><span class="p">,</span><span class="nb">id</span><span class="p">,</span><span class="n">modes_num</span><span class="p">,</span><span class="n">fields</span><span class="p">,</span><span class="n">U_FD</span><span class="p">,</span><span class="n">e_dressed</span><span class="p">,</span><span class="n">info</span><span class="p">):</span>
        <span class="n">h_floquet_size</span><span class="p">:</span> <span class="nb">int</span>
               <span class="n">size</span> <span class="n">of</span> <span class="n">the</span> <span class="n">multimode</span> <span class="n">Floquet</span> <span class="n">matrx</span>
        <span class="nb">id</span><span class="p">:</span> <span class="n">atom_c_T</span> <span class="n">instance</span>
        <span class="n">modes_num</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
               <span class="n">define</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="n">fundamental</span> <span class="n">frequencies</span> <span class="ow">and</span> <span class="n">modes</span>
               <span class="n">the</span> <span class="n">total</span> <span class="n">number</span> <span class="n">of</span> <span class="n">modes</span> <span class="ow">is</span> <span class="n">nm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">modes_num</span><span class="p">)</span>
        <span class="n">fields</span><span class="p">:</span> <span class="n">instance</span> <span class="n">of</span> <span class="n">openmmf</span><span class="o">.</span><span class="n">mode_c_T</span><span class="o">*</span><span class="n">nm</span>
               <span class="n">equivalent</span> <span class="n">to</span> <span class="n">the</span> <span class="n">FORTRAN</span> <span class="n">data</span> <span class="n">derived</span> <span class="nb">type</span> <span class="n">FIELDS</span>
        <span class="n">U_FD</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
             <span class="n">d_bare</span> <span class="n">x</span> <span class="n">d_bare</span> <span class="n">Matrix</span> <span class="n">of</span> <span class="n">the</span> <span class="n">time</span><span class="o">-</span><span class="n">average</span> <span class="n">state</span> <span class="n">occupationrs</span>
        <span class="n">e_dressed</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
               <span class="n">array</span> <span class="n">containing</span> <span class="n">the</span> <span class="n">eigenvalues</span> <span class="n">of</span> <span class="n">the</span> <span class="n">multimode</span> <span class="n">Floquet</span>
               <span class="n">Hamiltonian</span>
        <span class="n">info</span><span class="p">:</span> <span class="nb">int</span>
             <span class="n">Error</span><span class="o">/</span><span class="n">success</span> <span class="n">flag</span>


<span class="c1">#===================================================================</span>
<span class="c1">#  // DEFINITION OF DRESSED BASIS WITH A SUBSET OF THE FIELDS</span>
<span class="c1">#===================================================================</span>
<span class="k">def</span> <span class="nf">dressedbasis_subset</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">dressingfields_indices</span><span class="p">,</span><span class="n">modes_num</span><span class="p">,</span><span class="n">fields</span><span class="p">,</span><span class="n">U_FD</span><span class="p">,</span><span class="n">e_dressed</span><span class="p">,</span><span class="n">info</span><span class="p">):</span>
        <span class="nb">id</span><span class="p">:</span> <span class="n">atom_c_T</span> <span class="n">instance</span>
        <span class="n">dressingfields_indices</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
               <span class="n">define</span> <span class="n">the</span> <span class="n">index</span> <span class="n">of</span> <span class="n">dressing</span> <span class="n">fields</span>
        <span class="n">modes_num</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
               <span class="n">define</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="n">fundamental</span> <span class="n">frequencies</span> <span class="ow">and</span> <span class="n">modes</span>
               <span class="n">the</span> <span class="n">total</span> <span class="n">number</span> <span class="n">of</span> <span class="n">modes</span> <span class="ow">is</span> <span class="n">nm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">modes_num</span><span class="p">)</span>
        <span class="n">fields</span><span class="p">:</span> <span class="n">instance</span> <span class="n">of</span> <span class="n">openmmf</span><span class="o">.</span><span class="n">mode_c_T</span><span class="o">*</span><span class="n">nm</span>
               <span class="n">equivalent</span> <span class="n">to</span> <span class="n">the</span> <span class="n">FORTRAN</span> <span class="n">data</span> <span class="n">derived</span> <span class="nb">type</span> <span class="n">FIELDS</span>
        <span class="n">U_FD</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
             <span class="n">h_floquet_size</span> <span class="n">x</span> <span class="n">h_floquet_size</span> <span class="n">Matrix</span> <span class="n">of</span> <span class="n">eigenvectors</span>
        <span class="n">e_dressed</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
               <span class="n">array</span> <span class="n">containing</span> <span class="n">the</span> <span class="n">eigenvalues</span> <span class="n">of</span> <span class="n">the</span> <span class="n">multimode</span> <span class="n">Floquet</span>
               <span class="n">Hamiltonian</span>
        <span class="n">info</span><span class="p">:</span> <span class="nb">int</span>
             <span class="n">Error</span><span class="o">/</span><span class="n">success</span> <span class="n">flag</span>


<span class="k">def</span> <span class="nf">dressedbasis_subset_sp</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">dressingfields_indices</span><span class="p">,</span><span class="n">modes_num</span><span class="p">,</span><span class="n">fields</span><span class="p">,</span><span class="n">U_FD</span><span class="p">,</span><span class="n">e_dressed</span><span class="p">,</span><span class="n">info</span><span class="p">):</span>
        <span class="nb">id</span><span class="p">:</span> <span class="n">atom_c_T</span> <span class="n">instance</span>
        <span class="n">dressingfields_indices</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
               <span class="n">define</span> <span class="n">the</span> <span class="n">index</span> <span class="n">of</span> <span class="n">dressing</span> <span class="n">fields</span>
        <span class="n">modes_num</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
               <span class="n">define</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="n">fundamental</span> <span class="n">frequencies</span> <span class="ow">and</span> <span class="n">modes</span>
               <span class="n">the</span> <span class="n">total</span> <span class="n">number</span> <span class="n">of</span> <span class="n">modes</span> <span class="ow">is</span> <span class="n">nm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">modes_num</span><span class="p">)</span>
        <span class="n">fields</span><span class="p">:</span> <span class="n">instance</span> <span class="n">of</span> <span class="n">openmmf</span><span class="o">.</span><span class="n">mode_c_T</span><span class="o">*</span><span class="n">nm</span>
               <span class="n">equivalent</span> <span class="n">to</span> <span class="n">the</span> <span class="n">FORTRAN</span> <span class="n">data</span> <span class="n">derived</span> <span class="nb">type</span> <span class="n">FIELDS</span>
        <span class="n">U_FD</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
             <span class="n">h_floquet_size</span> <span class="n">x</span> <span class="n">h_floquet_size</span> <span class="n">Matrix</span> <span class="n">of</span> <span class="n">eigenvectors</span>
        <span class="n">e_dressed</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
               <span class="n">array</span> <span class="n">containing</span> <span class="n">the</span> <span class="n">eigenvalues</span> <span class="n">of</span> <span class="n">the</span> <span class="n">multimode</span> <span class="n">Floquet</span>
               <span class="n">Hamiltonian</span>
        <span class="n">info</span><span class="p">:</span> <span class="nb">int</span>
             <span class="n">Error</span><span class="o">/</span><span class="n">success</span> <span class="n">flag</span>




<span class="c1">#===================================================================</span>
<span class="c1">#  EVALUATE THE FOURIER COMPONENTS OF THE MICROMOTION OPERATOR USING THE DRESSING FIELDS</span>
<span class="c1">#===================================================================</span>
<span class="k">def</span> <span class="nf">micromotionfourierdressedbasis</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">dressingfields_indices</span><span class="p">,</span><span class="n">modes_num</span><span class="p">,</span><span class="n">fields</span><span class="p">,</span>
           <span class="n">U_FD</span><span class="p">,</span><span class="n">e_dressed</span><span class="p">,</span><span class="n">info</span><span class="p">):</span>
        <span class="nb">id</span><span class="p">:</span> <span class="n">atom_c_T</span> <span class="n">instance</span>
        <span class="n">dressingfields_indices</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
               <span class="n">define</span> <span class="n">the</span> <span class="n">index</span> <span class="n">of</span> <span class="n">dressing</span> <span class="n">fields</span>
        <span class="n">modes_num</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
               <span class="n">define</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="n">fundamental</span> <span class="n">frequencies</span> <span class="ow">and</span> <span class="n">modes</span>
               <span class="n">the</span> <span class="n">total</span> <span class="n">number</span> <span class="n">of</span> <span class="n">modes</span> <span class="ow">is</span> <span class="n">nm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">modes_num</span><span class="p">)</span>
        <span class="n">fields</span><span class="p">:</span> <span class="n">instance</span> <span class="n">of</span> <span class="n">openmmf</span><span class="o">.</span><span class="n">mode_c_T</span><span class="o">*</span><span class="n">nm</span>
               <span class="n">equivalent</span> <span class="n">to</span> <span class="n">the</span> <span class="n">FORTRAN</span> <span class="n">data</span> <span class="n">derived</span> <span class="nb">type</span> <span class="n">FIELDS</span>
        <span class="n">U_FD</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>

        <span class="n">e_dressed</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
               <span class="n">array</span> <span class="n">containing</span> <span class="n">the</span> <span class="n">eigenvalues</span> <span class="n">of</span> <span class="n">the</span> <span class="n">multimode</span> <span class="n">Floquet</span>
               <span class="n">Hamiltonian</span>
        <span class="n">info</span><span class="p">:</span> <span class="nb">int</span>
             <span class="n">Error</span><span class="o">/</span><span class="n">success</span> <span class="n">flag</span>

<span class="c1">#===================================================================</span>
<span class="c1">#  EVALUATE THE MICROMOTION OPERATOR USING THE DRESSING FIELDS</span>
<span class="c1">#===================================================================</span>
<span class="k">def</span> <span class="nf">micromotiondressedbasis</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span><span class="n">modes_num</span><span class="p">,</span><span class="n">dressingfields_indices</span><span class="p">,</span><span class="n">fields</span><span class="p">,</span><span class="n">t1</span><span class="p">,</span><span class="n">U</span><span class="p">,</span><span class="n">info</span><span class="p">):</span>
        <span class="nb">id</span><span class="p">:</span> <span class="n">atom_c_T</span> <span class="n">instance</span>
        <span class="n">modes_num</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
               <span class="n">define</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="n">fundamental</span> <span class="n">frequencies</span> <span class="ow">and</span> <span class="n">modes</span>
               <span class="n">the</span> <span class="n">total</span> <span class="n">number</span> <span class="n">of</span> <span class="n">modes</span> <span class="ow">is</span> <span class="n">nm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">modes_num</span><span class="p">)</span>
        <span class="n">dressingfields_indices</span><span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
               <span class="n">define</span> <span class="n">the</span> <span class="n">index</span> <span class="n">of</span> <span class="n">dressing</span> <span class="n">fields</span>
        <span class="n">fields</span><span class="p">:</span> <span class="n">instance</span> <span class="n">of</span> <span class="n">openmmf</span><span class="o">.</span><span class="n">mode_c_T</span><span class="o">*</span><span class="n">nm</span>
               <span class="n">equivalent</span> <span class="n">to</span> <span class="n">the</span> <span class="n">FORTRAN</span> <span class="n">data</span> <span class="n">derived</span> <span class="nb">type</span> <span class="n">FIELDS</span>
        <span class="n">t1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span>
             <span class="n">instant</span> <span class="n">of</span> <span class="n">time</span> <span class="n">to</span> <span class="n">evaluate</span> <span class="n">the</span> <span class="n">micromotion</span> <span class="n">operator</span>
        <span class="n">U</span> <span class="p">:</span> <span class="mi">1</span><span class="n">D</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>

        <span class="n">info</span><span class="p">:</span> <span class="nb">int</span>
             <span class="n">Error</span><span class="o">/</span><span class="n">success</span> <span class="n">flag</span>

<span class="c1">#===================================================================</span>
<span class="c1">#  DEALLOCATE ALL MEMORY ARRAYS</span>
<span class="c1">#===================================================================</span>
<span class="k">def</span> <span class="nf">deallocateall</span><span class="p">(</span><span class="nb">id</span><span class="p">):</span>
        <span class="nb">id</span><span class="p">:</span> <span class="n">atom_c_T</span> <span class="n">instance</span>
</pre></div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">How to build the library and compile the examples</a></li>
<li><a class="reference internal" href="#what-does-the-library-calculate-and-how">What does the library calculate and how?</a></li>
<li><a class="reference internal" href="#use-of-the-library">Use of the library</a><ul>
<li><a class="reference internal" href="#declaration-of-the-hamiltonian-subsec-init">Declaration of the Hamiltonian [subsec:init]</a></li>
<li><a class="reference internal" href="#hamiltonian-components">Hamiltonian components</a></li>
<li><a class="reference internal" href="#multimode-floquet-matrix-and-diagonalisation">Multimode Floquet matrix and diagonalisation</a></li>
<li><a class="reference internal" href="#time-evolution-operator">Time-evolution operator</a></li>
<li><a class="reference internal" href="#micromotion-operator">Micromotion operator</a></li>
<li><a class="reference internal" href="#identifying-the-dressing-modes">Identifying the dressing modes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#typical-performance">Typical performance</a></li>
<li><a class="reference internal" href="#default-system-types">Default system types</a><ul>
<li><a class="reference internal" href="#qubit">Qubit</a></li>
<li><a class="reference internal" href="#spin-of-total-angular-momentum-s-z">Spin of total angular momentum <span class="math notranslate nohighlight">\(S_z\)</span></a></li>
<li><a class="reference internal" href="#ground-state-alkali-atoms">Ground state Alkali atoms.</a></li>
</ul>
</li>
<li><a class="reference internal" href="#list-of-examples">List of examples</a><ul>
<li><a class="reference internal" href="#python">Python</a></li>
<li><a class="reference internal" href="#c">C++</a></li>
<li><a class="reference internal" href="#fortran">Fortran</a></li>
</ul>
</li>
<li><a class="reference internal" href="#c-wrappers">C++ wrappers</a></li>
<li><a class="reference internal" href="#python-wrappers">Python wrappers</a></li>
<li><a class="reference internal" href="#bugs-and-known-limitations">Bugs and known limitations</a></li>
<li><a class="reference internal" href="#acknowledgements">Acknowledgements</a></li>
<li><a class="reference internal" href="#modules">MODULES</a><ul>
<li><a class="reference internal" href="#physical-constants">Physical Constants</a></li>
<li><a class="reference internal" href="#arrays">Arrays</a></li>
<li><a class="reference internal" href="#atomic-properties">Atomic properties</a></li>
<li><a class="reference internal" href="#mkl">MKL</a></li>
</ul>
</li>
<li><a class="reference internal" href="#derived-types-src-modes-f90">DERIVED TYPES (src/modes.f90)</a></li>
<li><a class="reference internal" href="#computational-subroutines">COMPUTATIONAL SUBROUTINES</a></li>
<li><a class="reference internal" href="#driver-subroutines">DRIVER SUBROUTINES</a><ul>
<li><a class="reference internal" href="#utility-subroutines">Utility subroutines</a></li>
</ul>
</li>
<li><a class="reference internal" href="#c-wrappers-prototypes-src-multimodefloquet-h">C++ Wrappers prototypes: src/MultimodeFloquet.h</a></li>
<li><a class="reference internal" href="#python-wrappers-prototypes">Python Wrappers prototypes</a></li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="contributing.html"
                        title="previous chapter">Contributing</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="authors.html"
                        title="next chapter">Credits</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/MultimodeFloquet_test.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="authors.html" title="Credits"
             >next</a> |</li>
        <li class="right" >
          <a href="contributing.html" title="Contributing"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">ShakenOptic 0+untagged.14.gaa02efe.dirty documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, German Sinuco.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>